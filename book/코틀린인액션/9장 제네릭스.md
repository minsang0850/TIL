# 9.1 제네릭 타입 파라미터
## 9.1.1 제네릭 함수와 프로퍼티
람다 파라미터에 대해 자동으로 만들어진 변수 it의 타입은 T라는 제네릭 타입이다.

## 9.1.3 타입 파라미터 제약
타입 파라미터 제약(type parameter constraint)은 클래스나 함수에 사용할 수 있는 타입 인자를 제한하는 기능이다.
제약을 가하려면 타입 파라미터 이름 뒤에 콜론(:)을 표시하고 그 뒤에 상한 타입을 적으면 된다.
```kotlin
fun <T: Number> List<T>.sum(): T
```
타입 파라미터 T에 대한 상한을 정하고 나면 T 타입의 값을 그 상한 타입의 값으로 취급할 수 있다.

**여러 제약**
```kotlin
fun <T> ensureTrailingPeriod(seq: T)
    where T : CharSequence, T : Appendable {
        // ...
    }
```

## 9.1.4 타입 파라미터를 널이 될 수 없는 타입으로 한정
아무런 상한을 정하지 않은 타입 파라미터는 결과적으로 Any? 를 상한으로 정한 파라미터와 같다.

널을 막으려면 <T : Any>

# 9.2 실행 시 제네릭스의 동작: 소거된 타입 파라미터와 실체화된 타입 파라미터
## 9.2.1 실행 시점의 제네릭: 타입 검사와 캐스트
코틀린 제네릭 타입 인자 정보는 런타임에 지워진다. 이는 제네릭 클래스 인스턴스가 그 인스턴스를 생성할 때 쓰인 타입 인자에 대한 정보를 유지하지 않는다는 뜻이다.

**타입 소거로 인해 생기는 한계**  
타입 인자를 따로 저장하지 않기 때문에 실행 시점에 타입 인자를 검사할 수 없다.
```kotlin
if(value is List<String>) // 여기서 에러
```
반대로 메모리 사용량이 줄어든다는 장점이 있다.

그렇다면 어떤 값이 집합이나 맵이 아니라 리스트라는 사실을 어떻게 확인할 수 있을까? 바로 스타 프로젝션(star projection)을 사용하면 된다.
```kotlin
if (value is List<*>) { ... }
```
타입 파라미터가 2개 이상이라면 모든 타입 파라미터에 *를 포함시켜야 한다.
지금은 인자를 알 수 없는 제네릭 타입을 표현할 때 스타 프로젝션을 쓴다고만 알아두면 된다.

코틀린 컴파일러는 컴파일 시점에 타입 정보가 주어진 경우에는 is 검사를 수행하게 허용할 수 있을 정도로 똑똑하다.
```kotlin
fun printSum(c: Collection<Int>) {
    if (c is List<Int>) {
        print(c.sum())
    }
}
```

## 9.2.2 실체화한 타입 파라미터를 사용한 함수 선언
인라인 함수의 타입 파라미터는 실체화되므로 실행 시점에 인라인 함수의 타입 인자를 알 수 있다.

함수가 람다를 인자로 사용하는 경우 그 함수를 인라인 함수로 만들면 람다 코드도 함꼐 인라이닝되고, 그에 따라 무명 클래스와 객체가 생성되지 않아서 성능이 더 좋아질 수 있다.

함수를 인라인 함수로 만들고 타입 파라미터를 reified로 지정하면 value의 타입이 T의 인스턴스인지를 실행 시점에 검사할 수 있다.
```kotlin
inline fun <reified T> isA(value: Any) = value is T
```

**인라인 함수에서만 실체화한 타입 인자를 쓸 수 있는 이유?**  
컴파일러는 인라인 함수의 본문을 구현한 바이트코드를 그 함수가 호출되는 모든 지점에 삽입한다.
컴파일러는 실체화한 타입 인자를 사용해 인라인 함수를 호출하는 각 부분의 정확한 타입 인자를 알 수 있다.
따라서 컴파일러는 타입 인자로 쓰인 구체적인 클래스를 참조하는 바이트코드를 생성해 삽입할 수 있다.
타입 파라미터가 아닌 구체적인 타입을 사용하므로 만들어진 바이트코드는 실행 시점에 벌어지는 타입 소거의 영향을 받지 않는다.

## 9.2.3 실체화한 타입 파라미터로 클래스 참조 대신
```kotlin
inline fun <reified T> loadService() {
    return ServiceLoader.load(T::class.java)
}
```

## 9.2.4 실체화한 타입 파라미터의 제약
다음과 같은 경우에 실체화한 타입 파라미터를 사용할 수 있다
- 타입 검사와 캐스팅(is, !is, as, as?)
- 코틀린 리플렉션 API(::class)
- 코틀린 타입에 대응하는 java.lang.Class를 얻기(::class.java)
- 다른 함수를 호출할 때 타입 인자로 사용

할 수 없는 일
- 타입 파라미터 클래스의 인스턴스 생성하기
- 타입 파라미터 클래스의 동반 객체 메서드 호출하기
- 실체화한 타입 파라미터를 요구하는 함수를 호출하면서 실체화하지 않은 타입 파라미터로 받은 타입을 타입 인자로 넘기기
- 클래스, 프로퍼티, 인라인 함수가 아닌 함수의 타입 파라미터를 reified로 지정하기

마지막 제약으로 인해 흥미로운 파급 효과가 생긴다.
실체화한 타입 파라미터를 인라인 함수에만 사용할 수 있으므로 실체화한 타입 파라미터를 사용하는 함수는 자신에게 전달되는 모든 람다와 함께 인라이닝된다.
람다 내부에서 타입 파라미터를 사용하는 방식에 따라서는 람다를 인라이닝할 수 없는 경우가 생기기도 하고 성능 문제로 람다를 인라이닝하고 싶지 않을 수도 있다.

# 9.3 변성: 제네릭과 하위 타입
변성은 List<String>와 List<Any>와 같이 기저 타입이 같고 타입 인자가 다른 여러 타입이 서로 어떤 관계가 있는지 설명하는 개념이다.

## 9.3.1 변성이 있는 이유: 인자를 함수에 넘기기
```kotlin
fun addAnswer(list: MutableList<Any>) {
    list.add(42)
}
```
위 함수에 문자열 리스트를 넘기면 예외 발생. -> 위험할 수 있다는 뜻

## 9.3.2 클래스, 타입, 하위 타입
제네릭 클래스가 아닌 클래스에서는 클래스 이름을 바로 타입으로 쓸 수 있다.

제네릭 클래스에서는 올바른 타입을 얻으려면 제네릭 타입의 타입 파라미터를 구체적인 타입 인자로 바꿔줘야 한다.
예를 들어 List는 타입이 아니다(하지만 클래스다).
하지만 타입 인자를 치환한 List<Int>, List<String?> 등은 모두 제대로 된 타입이다.
각각의 제네릭 클래스는 무수히 많은 타입을 만들어낼 수 있다.

타입 사이의 관계를 논하기 위해 하위 타입(subtype)이라는 개념을 잘 알아야 한다.
타입 A의 값이 필요한 모든 장소에 어떤 타입 B의 값을 넣어도 아무 문제가 없다면 타입 B는 타입 A의 하위 타입이다.

Int는 Number의 하위 타입. 
모든 타입이 자신의 하위 타입이다.

간단한 경우 하위 타입은 하위 클래스와 근본적으로 같다.
Int 클래스는 Number의 하위 클래스이므로 Int는 Number의 하위 타입이다.

널이 될 수 있는 타입은 하위 타입과 하위 클래스가 같지 않은 경우를 보여주는 예다.

널이 될 수 이쓴 타입은 널이 될 수 있는 타입의 하위 타입이다.
하지만 두 타입 모두 같은 클래스에 해당한다.
항상 널이 될 수 없는 타입의 값을 널이 될 수 있는 타입의 변수에 저장할 수 있지만 거꾸로는 불가하다.

"List<String> 타입의 값을 List<Any>를 파라미터로 받는 함수에 전달해도 괜찮은가?" 라는 질문은
"List<String>은 List<Any>의 하위 타입인가?" 다.

제네릭 타입을 인스턴스화할 때 타입 인자로 서로 다른 타입이 들어가면 인스턴스 타입 사이의 하위 타입 관계가 성립하지 않으면 그 제네릭 타입을 무공변(invariant)이라고 말한다.
자바에서는 모든 클래스가 무공변이다.

A가 B의 하위 타입이면 List<A>는 List<B>의 하위 타입이다. 그런 클래스나 인터페이스를 공변적이라 말한다.

## 9.3.3 공변성: 하위 타입 관계를 유지
A가 B의 하위 타입일 때 Producer<A>가 Producer<B>의 하위 타입이면 Producer는 공변적이다.
예를 들어 Cat가 Animal의 하위 타입이기 때문에 Producer<Cat>은 Producer<Animal>의 하위 타입이다.

코틀린에서 제네릭 클래스가 타입 파라미터에 대해 공변적임을 표시하려면 타입 파라미터 이름 앞에 out을 넣어야 한다.
-> "T를 반환(return)하기만 하고, T를 소비(consume)는 하지 않겠다"는 약속.

모든 클래스를 공변적으로 만들 수는 없다. 공변적으로 만들면 안전하지 못한 클래스도 있다.
타입 파라미터를 공변적으로 지정하면 클래스 내부에서 그 파라미터를 사용하는 방법을 제한한다.

코틀린의 List<T> 인터페이스를 보자.
코틀린 List는 읽기 전용이다. 따라서 그 안에는 T 타입의 원소를 반환하는 get 메서드는 있지만 리스트에 T 타입의 값을 추가하거나 리스트에 있는 기존 값을 변경하는 메서드는 없다.
따라서 List는 T에 대해 공변적이다.

MutableList<T>를 타입 파라미터 T에 대해 공변적인 클래스로 선언할 수는 없다는 점에 유의하라. 

생성자는 in, out 어느 쪽도 아니다.

## 9.3.4 반공변성: 뒤집힌 하위 타입 관계
반공변성(contravariance)은 공변성을 거울에 비친 상이라 할 수 있다.
반공변 클래스의 하위 타입 관계는 공변 클래스의 경우와 반대다.
```kotlin
interface Comparator<in T> {
    fun compare(e1: T, e2: T): Int { 
    //...
    }
}
```
이 인터페이스의 메서드는 T 타입의 값을 소비하기만 한다.
물론 어떤 타입에 대해 Comparator를 구현하면 그 타입의 하위 타입에 속하는 모든 값을 비교할 수 있다.

어떤 타입의 객체를 Comparator로 비교해야 한다면 그 타입이나 그 타입의 조상 타입을 비교할 수 있는 Comparator를 사용할 수 있다.
이는 Comparator<Any>가 Comparator<String>의 하위 타입이라는 뜻이다. 그런데 여기서 Any는 String의 상위 타입이다.
따라서 서로 다른 타입 인자에 대해 Comparator이ㅡ 하위 타입 관계는 타입 인자의 하위 타입 관계와는 정반대 방향이다.

타입 B가 타입 A의 타입인 경우 Consumer<A>가 Consumer<B>의 하위 타입인 관계가 성립하면 제니릭 클래스 Consumber<T>는 타입 인자 T에 대해 반공변이다.

클래스나 인터페이스가 어떤 타입 파라미터에 대해서는 공변적이면서 다른 타입 파라미터에 대해서는 반공변적일 수도 있다.
```kotlin
interface Function1<in P, out R> {
    operator fun invoke(p: P) : R
}
```

클래스 정의에 변성을 직접 기술하면 그 클래스를 사용하는 모든 장소에 그 변성이 적용된다는 점을 알 수 있다. 자바는 이를 지원하지 않는다.
대신 클래스를 사용하는 위치에서 와일드카드를 사용해 그때그때 변셩을 지정해야 한다.

## 9.3.5 사용 지점 변성: 타입이 언급되는 지점에서 변성 지정
클래스를 선언하면서 변성을 지정하면 그 클래스를 사용하는 모든 장소에 변성 지정자가 영향을 끼치므로 편리하다.
이런 방식을 선언 지점 변성(declaration site variance)이라 부른다.

자바는 사용 지점 변성(use-site variance) 
코틀린도 사용 지점 변성을 지원한다.

## 9.3.6 스타 프로젝션: 타입 인자 대신 * 사용
원소 타입이 알려지지 않은 리스트는 List<*> 라는 구문으로 표현할 수 있다.
- MutableList<*>는 MutableLIst<Any?>와 같지 않다. 
  - MutableList<*>는 어떤 정해진 구체적인 타입의 원소를 담는 리스트지만 그 원소의 타입을 정확히 모른다는 사실을 표현한다.
  - MutableList<*>는 MutableList<out Any?>처럼 동작한다.

사용 지점 변성과 마찬가지로 스타 프로젝션도 우회하는 방법이 있는데, 제네릭 타입 파라미터를 도입하면 된다.
```kotlin
fun <T> printFirst(list: List<T>) {
    if(list.isNotEmpty()) {
        println(list.first())
    }
}
```
스타 프로젝션을 쓰는 쪽에 더 간결하지만 제네릭 타입 파라미터가 어떤 타입인지 굳이 알 필요가 없을 때만 스타 프로젝션을 사용할 수 있다.
스타 프로젝션을 사용할 때는 값을 만들어내는 메서드만 호출할 수 있고 그 값의 타입에는 신경을 쓰지 말아야 한다.