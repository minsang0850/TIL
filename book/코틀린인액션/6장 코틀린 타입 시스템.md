## 6.1 널 가능성
NPE를 피할 수 있게 돕는 코틀린 타입 시스템의 특성
코틀린을 비롯한 최신 언어에서 null에 대한 접근 방법은 가능한 한 이 문제를 실행 시점에서 컴파일 시점으로 옮기는 것이다.

### 널이 될 수 있는 타입
널을 받을 수 있는 타입으로 선언하려면 이름 뒤에 물음표(?)를 명싷해야 한다.
```kotlin
fim strlenSafe(s: String?) = ...
```

- 널이 될 수 있는 타입의 변수가 있다면 그에 대해 수행할 수 있는 연산이 제한된다.
- 널이 될 수 있는 값을 널이 될 수 없는 타입의 변수에 대입할 수 없다.
- 널이 될 수 있는 타입의 값을 널이 될 수 없는 타입의 파라미터를 받는 함수에 전달할 수 없다.

그러면 nullable 타입으로 뭘 할 수 있을까? null과 비교하는 것이다.

### 6.1.2 타입의 의미
타입은 어떤 값들이 가능한지와 그 타입에 대해 수행할 수 있는 연산의 종류를 결정한다.

String과 null은 실행할 수 있는 연산도 다르고, 값도 다르다. -> 자바의 타입 시스템이 널을 제대로 다루지 못한다는 뜻이다.

### 6.1.3 안전한 호출 연산자: ?.
?.은 null 검사와 메서드 호출을 한 번의 연산으로 수행한다.

```kotlin
s?.toUpperCase()
// if(s!=null) s.toUpperCase() else null 과 같다.
```
안전한 호출의 결과 타입도 nullable임을 유의하자.

### 6.1.4 엘비스 연산자: ?:
이 연산자는 이항 연산자로 좌항을 계산한 값이 널인지 검사한다. 좌항 값이 널이 아니면 좌항 값을 결과로 하고, 좌항 값이 널이면 우항 값을 결과로 한다.

코틀린에서는 return이나 throw 등의 연산도 식이기 때문에 엘비스 연산자의 우항에 return, throw 등의 연산을 넣을 수 있다.

### 6.1.5 안전한 캐스트: as?
foo as? Type
foo is Type -> foo as Type
foo !is Type -> null

### 6.1.6 널 아님 단언: !!
!! 을 사용하면 어떤 값이든 널이 될 수 없는 타입으로 (강제로) 바꿀 수 있다.
-> 원래 값이 null 이면 NPE 발생

!!을 한 줄에서 여러번 쓰면 NPE 발생 시 어떤 식에서 예외가 발생했는지 찾기 어렵다.

### 6.1.7 let 함수
foo?.let { ...it... }
- foo != null -> it은 람다 안에서 null 아니다
- foo == null -> 아무 일도 일어나지 않는다.

### 6.1.8 나중에 초기화할 프로펕티
코틀린에서 클래스 안의 널이 될 수 없는 프로퍼티를 생성자 안에서 초기화하지 않고 특별한 메서드 안에서 초기화할 수는 없다.

lateinit 변경자를 붙이면 프로퍼티를 나중에 초기화할 수 있다. 해당 프로퍼티는 항상 var여야 한다.

### 6.1.9 널이 될 수 있는 타입 확장
코틀린에서는 널이 될 수 있는 타입의 확장 함수 안에서는 this가 널이 될 수 있다.

### 6.1.10 타입 파라미터의 널 가능성
코트린에서는 함수나 클래스의 모든 타입 파라미터는 기본적으로 널이 될 수 있다.
따라서 타입 파라미터 T를 클래스나 함수 안에서 타입 이름으로 사용하면 이름 끝에 물음표가 없더라고 T가 널이 될 수 있는 타입이다.

타입 파라미터가 널이 아님을 확실히 하려면 널이 될 수 없는 타입 상함(upper bound)를 지정해야 한다.
```kotlin
fun <T: Any> printHashCode(t: T) {
    println(t.hashCode())
}
```

### 6.1.11 널 가능성과 자바
자바 코드에 애너테이션으로 표시된 널 가능성 정보(@Nullable, @NotNull)가 있고, 코틀린도 그 정보를 활용한다.

**플랫폼 타입**  
플랫폼 타입은 코틀린이 널 관련 정보를 알 수 없는 타입을 말한다.
플랫폼 타입에 대해 수행하는 모든 연산에 대한 책임은 온전히 사용자에게 있다는 뜻이다.

**상속**  
코틀린에서 자바 메서드를 오버라이드할 때 그 메서드의 파라미터와 반환 타입을 nullable 타입으로 선언할지 결정해야 한다.

## 6.2 코틀린의 원시 타입
코틀린은 원시 타입과 래퍼 타입을 구분하지 않는다.

### 6.2.1 원시 타입: Int, Boolean 등
래퍼 타입을 따로 구분하지 않기에 편리하다.

원시 타입과 참조 타입이 같다면 코틀린이 그들을 항상 객체로 표현하는 걸까?
그렇게 한다면 비효율적이겠지만 코틀린은 그러지 않는다.

실행 시점에 숫자 타입은 가능한 가장 효율적인 방식으로 표현된다.

대부분의 경우 코틀린의 Int 타입은 자바 int 타입으로 컴파일된다.

이런 컴파일이 불가능한 경우는 컬렉션과 같은 제네릭 클래스를 사용하는 경우뿐이다.
Int 타입의 컬렉션의 타입 파라미터로 넘기면 그 컬렉션에는 Int의 래퍼타입에 해당하는 java.lang.Integer 객체가 들어간다.

### 6.2.2 널이 될 수 있는 원시 타입: Int? Boolean? 등
널이 될 수 있는 코틀린 타입은 자바 원시 타입으로 표현할 수 없다.
따라서 코틀린에서 널이 될 수 있는 원시 타입을 사용하면 그 타입은 자바의 래퍼 타입으로 컴파일된다.

JVM은 타입 인자로 원시 타입을 허용하지 않는다. 따라서 자바나 코틀린 모두에서 제네릭 클래스는 항상 박스 타입을 사용해야 한다.

### 6.2.3 숫자 변환
코틀린에선 Int -> Long 자동 변환이 불가하다.
```kotlin
// 옳은 방식
val i = 1
val l: Long = i.toLong()
```
코틀린은 모든 원시 타입에 대한 변환함수를 제공한다.

표현 범위가 더 좁은 타입으로 변환하면서 값을 벗어나는 경우에는 일부를 잘라내는 함수도 있다. (하위 32비트만 남김)

코드에서 동시에 여러 숫자 타입을 사용하려면 예상치 못한 동작을 피하기 위해 각 변수를 명시적으로 변환해야 한다.

### 6.2.4 Any, Any?: 최상위 타입
자바에서 Object가 클래스 계층의 최상위 타입이듯 코틀린에서는 ANy 타입이 모든 널이 될 수 없는 타입의 조상 타입이다.
하지만 자바에서는 참조 타입만 Object를 정점으로 하는 타입 계층에 포함되며, 원시 타입은 그런 계층에 들어있지 않다.
하지만 코틀린에선 Qny가 Int 등의 원시 타입을 포함한 모든 타입의 조상 타입이다.

자바 메서드에서 Object를 인자로 받거나 반환하면 코틀린에서는 ANy로 그 탕비을 취급한다. 반대도 마찬가지다.

### 6.2.5 Unit 타입: 코틀린의 void
코틀린 Unit 타입은 자바 void와 같은 기능을 한다.
Unit은 모든 기능을 갖는 일반적인 타입이며, void와 달리 Unit을 타입 인자로 쓸 수 있다. Unit 타입에 속한 값은 단 하나뿐이며, 그 이름도 Unit 이다.

함수형 프로그래밍에서 전통적으로 Unit은 '단 하나의 인스턴스만 갖는 타입'을 의미해왔고 바로 그 유일한 인스턴스의 유무가 자바 void와 코틀린 Unit을 구분하는 가장 큰 차이다.

### 6.2.6 Nothing 타입: 이 함수는 결코 정상적으로 끝나지 않는다
테스트 라이브러리들은 fail이라는 함수를 제공하는 경우가 많다.
그런 경우를 표현하기 위해 코틀린에는 Nothing이라는 특별한 반환 타입이 있다.

Nothing은 함수의 반환 타입이나 반환 타입으로 쓰일 타입 파라미터로만 쓸 수 있다.

## 6.3 컬렉션과 배열
### 6.3.2 읽기 전용과 변경 가능한 컬렉션
Collection은 읽기 전용  
변경을 위해서는 MutableCollection을 사용

list: List<String> 과 mutableList:MutableList<String>이 동일한 리스트를 가리키고 있는 상황이라면
읽기 전용 컬렉션이항상 스레드 안전하지는 않다는 것을 명ㅅ미해야 한다.

### 6.3.3 코틀린 컬렉션과 자바
모든 코틀린 컬렉션은 그에 상응하는 자바 컬렉션 인터페이스의 인스턴스라는 점은 사실이다.
컬렉션을 코틀린과 자바 두 곳에서 사용할때는 주의를 해야한다.

### 6.3.4 컬렉션을 플랫폼 타입으로 다루기
플랫폼 타입의 경우 코틀린 쪽에는 널 관련 정보가 없다.

컬렉션 타입이 시그니처에 들어간 자바 메서드 구현을 오버라이드하려는 경우 읽기 전용 컬렉션과 변경 가능 컬렉션의 차이가 문제가 된다.
이런 경우에 오버라이드하려는 메서드의 자바 컬렉션 타입을 어떤 코틀린 컬렉션 타입으로 표현할지 결정해야 한다.

- 컬렉션이 널이 될 수 있는가?
- 컬렉션의 원소가 널이 될 수 있는가?
- 오버라이드하는 메서드가 컬렉션을 변경할 수 있는가?

위 요소를 고려해야 한다.

### 6.3.5 객체의 배열과 원시 타입의 배열
코틀린의 Array 클래스는 일반 제네릭 클래스처럼 보이지만, 자바 배열로 컴파일된다.

코틀린에서 배열을 만드는 방법
- arrayOf 함수에 원소를 넘기면 배열을 만들 수 있다
- arrayOfNulls 함수에 정수 값을 인자로 넘기면 모든 원소가 null이고 인자로 넘긴 값과 크기가 같은 배열을 만들 수 있다.
- Array 생성자는 배열 크기와 람다를 인자로 받아서 람다를 호출해서 각 배열 원소를 초기화해준다.

toTypedArray 메서드를 사용하면 쉽게 컬렉션을 배열로 바꿀 수 있다.

IntArray(코틀린) == int[](자바)

코틀린 표준 라이브러리는 배열 기본 연산에 더해 컬렉션에 사용할 수 있는 모든 확장 함수를 배열에도 제공한다.



