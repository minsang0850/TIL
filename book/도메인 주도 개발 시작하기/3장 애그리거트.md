# 3.1 애그리거트
도메인 객체 모델이 복잡해지면 개별 구성요소 위주로 모델을 이해하게 되고 전반적인 구조나 큰 수준에서 도메인 간의 관계를 파악하기 어려워진다.

복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요한데, 그 방법이 바로 애그리거트다.
애그리거트는 모델을 이해하는 데 도움을 줄 뿐만 아니라 일관성을 관리하는 기준도 된다.

애그리거트에 속한 객체는 유사하거나 동일한 라이프 사이클을 갖는다.

애그리거트 경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항이다.

'A가 B를 갖는다'의 형태여도 A와 B가 한 애그리거트에 속하지 않을 수 있다. ex) 상품, 리뷰

# 3.2 애그리거트 루트
애그리거트는 여러 객체로 구성되기 때문에 한 객체만 상태가 정상이면 안 된다.
도메인 규칙을 지키려면 애그리거트에 속한 모든 객체가 정상 상태를 가져야 한다.

애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데, 이 책임을 지는 것이 바로 애그리거트의 루트 엔티티이다.

## 3.2.1 도메인 규칙과 일관성
애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이다.

애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들려면 도메인 모델에 대해 다음의 두 가지를 습관적으로 적용해야 한다.
- 단순히 필드를 변경하는 set 메서드를 public 범위로 만들지 않는다.
- 밸류 타입은 불변으로 구현한다.

밸류 타입의 내부 상태를 변경하려면 애그리거트 루트를 통해서만 가능하다.

## 3.2.2 애그리거트 루트의 기능 구현
애그리거트 루트는 애그리거트 냉부의 다른 객체를 조합해서 기능을 완성한다.

애그리거트 루트가 구성요소의 상태만 참조하는 것은 아니다. 기능 실행을 위임하기도 한다.

## 3.2.3 트랜잭션 범위
한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다.

만약 부득이하게 한 트랜잭션으로 두 개 이상의 애그리거트를 수정해야 한다면 애그리거트에서 다른 애그리거트를 직접 수정하지 말고 응용 서비스에서 두 애그리거트를 수정하도록 구현한다.

# 3.3 리포지터리와 애그리거트
애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재한다.

애그리거트를 구하는 리포지터리 메서드는 완전한 애그리거트를 제공해야 한다.

# 3.4 ID를 이용한 애그리거트 참조
애그리거트 간의 참조는 A 애그리거트의 루트가 다른 애그리거트의 루트를 참조한다는 의미.

JPA는 @ManyToOne, @OneToOne과 같은 애너테이션을 이용해ㅓㅅ 연관된 객체를 로딩하는 기능을 제공하고 있으므로 필드를 이용해 다른 애그리거트를 쉽게 참조할 수 있다.

필드를 이용한 애그리거트 참조는 다음 문제를 야기할 수 있다.
- 편한 탐색 오용
- 성능에 대한 고민
- 확장 어려움

다른 애그리거트의 상태를 쉽게 변경할 수 있어서 유혹에 빠지기 쉽다.
지연(lazy)로딩과 즉시(eager)로딩의 두 가지 방식으로 로딩할 수 있어서 이를 잘 컨트롤해야한다.
서비스가 커지다 보면 JPA와 같은 단일 기술을 사용할 수 없게될 수도 있다.

이 세가지 문제를 완화할 때 사용할 수 있는 것이 ID를 이용해서 다른 애그리거트를 참조하는 것이다.

## 3.4.1 ID를 이용한 참조와 조회 성능
다른 애그리거트를 ID로 참조하면 참조하는 여러 애그리거트를 읽을 때 조회 속도가 문제될 수 있다. (N+1 조회 문제)
이를 막기 위해 조인을 사용한다.
조인을 사용하는 가장 쉬운 방법은 ID 참조 방식을 객체 참조 방식으로 바꾸고 즉시 로딩을 사용하도록 매핑 설정을 바꾸는 것이다.

애그리거트마다 서로 다른 저장소를 사용하면 한 번의 쿼리로 관련 애그리거트를 조회할 수 없어 성능이 느려질 수 있다.
이를 방어하기 위해 캐시를 적용하거나 조회 전용 저장소를 따로 구성한다.

# 3.5 애그리거트 간 집합 연관
개념적으로 존재하는 애그리거트 간의 1-N 연관을 실제 구현에 반영하는 것이 요구사항을 충족하는 것과는 상관없을 때가 있다.

1-N으로 구현하면 N개를 가져오고, 그 다음에 코드 상에서 페이징을 하게 된다.
이런 경우를 막기 위해 일반적으로 애그리거트 간의 1-N 연관을 실제 구현에 반영하지 않는다.

# 3.6 애그리거트를 팩토리로 사용하기
Shop 애그리거트에서 Product 애그리거트를 생성(팩토리 역할).
