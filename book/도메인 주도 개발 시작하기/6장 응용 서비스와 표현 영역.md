# 6.1 표현 영역과 응용 영역
표현 영역은 사용자의 요청을 해석한다.

실제 사용자가 원하는 기능을 제공하는 것은 응용 영역에 위치한 서비스다.

응용 서비스의 메서드가 요구하는 파라미터와 표현 영역이 사용자로부터 전달받은 데이터는 형식이 일치하지 않기 떄문에 표현 영역은 응용 서비스가 요구하는 형식으로 사용자 요청을 변환한다.

응용 서비스를 실행한 뒤에 표현 영역은 실행 결과를 사용자에게 알맞은 형식으로 응답한다.

사용자와 상호작용은 표현 영역이 처리하기 때문에, 응용 서비스는 표현 영역에 의존하지 않는다. 단지 기능 실행에 필요한 입력 값을 받고 실행 결과만 리턴하면 될 뿐이다.

# 6.2 응용 서비스의 역할
응용 서비스는 사용자의 요청을 처리하기 위해 리포지터리에서 도메인 객체를 가져와 사용한다.

응용 서비스의 주요 역할은 도메인 객체를 사용해서 사용자의 요청을 처리하는 것이므로 표현 영역 입장에서 보았을 때 응용 서비스는 도메인 영역과 표현 영역을 연결해 주는 창구 역할을 한다.
```kotlin
public Result doSomeFunc(SomeReq req) {
    // 리포지터리에서 애그리거트를 구한다.
    SomeAgg agg = someAggRepository.findById(req.getId());
    checkNull(agg);
    
    // 애그리거트의 도메인 기능을 실행한다.
    agg.doFunc(req.getValue());
    
    // 결과를 리턴한다
    return createSuccessResult(agg);
}
```

응용 서비스가 복잡하다면 응용 서비스에서 도메인 로직의 일부를 구현하고 있을 가능성이 높다.

응용 서비스는 트랜잭션 처리도 담당한다.

## 6.2.1 도메인 로직 넣지 않기
도메인 로직을 도메인 영역과 응용 서비스에 분산해서 구현하면 코드 품질에 문제가 발생한다.  
첫 번째 문제는 코드의 응집성이 떨어진다는 것이다.  
두 번째 문제는 여러 응용 서비스에서 동일한 도메인 로직을 구현할 가능성이 높아진다는 것이다.
위 두 가지 문제가 코드 변경을 어렵게 만든다.

# 6.3 응용 서비스의 구현
응용 서비스는 표현 영역과 도메인 영역을 연결하는 매개체 역할을 하는데 이는 디자인 패턴에서 파사드와 같은 역할을 한다.

## 6.3.1 응용 서비스의 크기
응용 서비스 구현의 방식
- 한 응용 서비스 클래스에 회원 도메인의 모든 기능 구현하기
  - 코드 중복 제거하기가 쉬움
  - 서비스 클래스 하나의 코드가 길어짐
- 구분되는 기능별로 응용 서비스 클래스를 따로 구현하기
  - 별도 클래스에 로직을 구현해서 코드가 중복되는 것을 방지할 수 있다.

필자는 각 클래스마다 구분되는 역할을 갖는 것을 선호한다고 함.

## 6.3.2 응용 서비스의 인터페이스와 클래스
인터페이스를 만드는게 필요할까?

인터페이스가 필요한 몇 가지 상황이 있는데 그 중에 하나는 구현 클래스가 여러 개인 경우다.
그런데 응용 서비스는 런타임에 교체하는 경우가 거의 없고 한 응용 서비스의 구현 클래스가 두 개인 경우도 드물다.

TDD를 사용하면 인터페이스부터 작성하게 된다.
MOckito와 같은 테스트 도구는 클래스에 대해서도 테스트용 대역 객체를 만들 수 있기 때문에 응용 서비스에 대한 인터페이스가 없어도 표현 영역을 테스트할 수 있다.

## 6.3.3 메서드 파라미터와 값 리턴
응용 서비스에 데이터로 전달할 요청 파라미터가 두 개 이상 존재하면 데이터 전달을 위한 별도 클래스를 사용하는 것이 편리하다.

응용 서비스의 결과를 표현 영역에서 사용해야 하면 응용 서비스 메서드의 결과로 필요한 데이터를 리턴한다.

결과 데이터가 필요한 대표적인 예가 식별자다. (주문 후 바로 상세 내역을 보기 위해)

응용 서비스에서 애그리거트 자체를 리턴하면 코딩은 편할 수 있지만 도메인의 로직 실행을 응용 서비스와 표현 영역 두 곳에서 할 수 있게 된다.
이것은 기능 실행 로직을 응용 서비스와 표현 영역에 분산시켜 코드의 응집도를 낮추는 원인이 된다.

## 6.3.4 표현 영역에 의존하지 않기
응용 서비스의 파라미터 타입을 결정할 때 주의할 점은 표현 영역과 관련된 타입을 사용하면 안 된다는 점이다. (HttpServletRequest X)
- 응용 서비스 단독 테스트 어렵
- 표현 영역 구현이 변경되면 응용 서비스의 구현도 함께 변경해야 함
- 응용 서비스가 표현 영역의 역할까지 대신하는 상황이 벌어질 수도 있다.

이를 지키기 위한 쉬운 방법은 서비스 메서드의 파라미터와 리턴 타입으로 표현 영역의 구현 기술을 사용하지 않는 것이다.

## 6.3.5 트랜잭션 처리
트랜잭션을 관리하는 것은 응용 서비스의 중요한 역할이다.
프레임워크가 제공하는 트랜잭션 기능을 적극 사용하는 것이 좋다.

# 6.4 표현 영역
**표현 영역의 책임**
- 사용자가 시스템을 사용할 수 있는 흐름을 제공하고 제어한다.
- 사용자의 요청을 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공한다.
- 사용자의 세션을 관리한다.

# 6.5 값 검증
값 검증은 표현과 응용 서비스 두 곳에서 모두 수행할 수 있다.
원칙적으로 모든 값에 대한 검증은 응용 서비스에서 처리한다.
그런데 표현 영역은 잘못된 값이 존재하면 이를 사용자에게 알려주고 값을 다시 입력받아야 한다.

스프링과 같은 프레임워크는 값 검증을 위한 Validator 인터페이스를 별도로 제공하므로 이 인터페이스를 구현한 검증기를 따로 구현하면 간결하게 바꿀 수 있다.

표현 영역에서 필수 값과 값의 형식을 검사하면 실질적으로 응용 서비스는 ID 중복 여부와 같은 논리적 오류만 검사하면 된다.
즉 표현 영역과 응용 서비스가 값 검사를 나눠서 수행하는 것이다.
 - 표현 영역: 필수 값, 값의 형식, 범위 등을 검증한다.
 - 응용 서비스: 데이터의 존재 유무와 같은 논리적 오류를 검증한다.

필자는 가능하면 응용 서비스에서 필수 값 검증과 논리적인 검증을 모두 하는 편이라고 한다. -> 응용 서비스의 완성도를 높이기 위해.

# 6.6 권한 검사
세 곳에서 권한 검사를 수행할 수 있다.
- 표현 영역: 인증된 사용자인지 아닌지 검사 -> 서블릿 필터
- 응용 서비스
- 도메인

# 6.7 조회 전용 기능과 응용 서비스
단순 조회 전용 기능은 응용 서비스 없이 바로 DAO나 리포지터리를 호출할 수도 있다.