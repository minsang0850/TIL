# 4.1 JPA를 이용한 리포지터리 구현
## 4.1.1 모듈 위치
리포지터리 인터페이스는 애그리거트와 같이 도메인 영역에 속하고, 리포지터리를 구현한 클래스는 인프라스트럭처 영역에 속한다.

## 4.1.2 리포지터리 기본 기능 구현
- ID로 애그리거트 조회하기
- 애그리거트 저장하기
```java
public interface OrderRepository {
    Order findById(ORderNo no);
    void save(Order order);
}
```

JPA를 사용하면 트랜잭션 범위에서 변경한 데이터를 자동으로 DB에 반영하기 때문에 저장소에 반영하는 메서드를 추가할 필요는 없다.

# 4.2 스프링 데이터 JPA를 이용한 리포지터리 구현
스프링 데이터 JPA는 지정한 규칙에 맞게 리포지터리 인터페이스를 정의하면 리포지터리를 구현한 객체를 알아서 만들어 스프링 빈으로 등록해준다.
리포지터리 인터페이스를 직접 구현하지 않아도 되기 때문에 개발자는 리포지터리를 쉽게 정의할 수 있다.

스프링 데이터 JPA는 다음 규칙에 따라 작성한 인터페이스를 찾아서 인터페이스를 구현한 스프링 빈 객체를 자동으로 등록한다.
- org.springframework.data.repository.Repository<T, ID> 인터페이스 상속
- T는 엔티티 타입을 지정하고 ID는 식별자 타입을 지정

# 4.3 매핑 구현
## 4.3.1 엔티티와 밸류 기본 매핑 구현
애그리거트와 JPA 매핑을 위한 기본 규칙은 다음과 같다.
- 애그리거트 루트는 엔티티이므로 @Entity로 매핑 설정한다.

한 테이블에 엔티티와 밸류 데이터가 같이 있다면
- 밸류는 @Embeddable로 매핑 설정한다.
- 밸류 타입 프로퍼티는 @Embedded로 매핑 설정한다.

Order: 루트 엔티티 - JPA의 @Entity로 매핑
Orderer, ShoppingInfo: 밸류 - @Embeddable로 매핑

```java
@Embeddable
public class Orderer {
    @Embedded
    @AttributeOverrides(
        @AttributeOVerride(name = "id", column = @Column(name = "orderer_id"))
    )

    private MemberId memberId;

    @Column(name = "orderer_name")
    private String name;
}
```

Orderer의 memberId는 Member 애그리거트를 ID로 참조한다.
Member의 ID 타입으로 사용되는 MemberId는 다음과 같이 id 프로퍼티와 매핑되는 테이블 칼럼 이름으로 "member_id"를 지정하고 있다.
```java
@Embeddable
public class MemberId implements Serializable {
    @Column(name = "member_id")
    private String id;
}
```

루트 엔티티인 Order 클래스는 @Embedded를 이용해서 밸류 타입 프로퍼티를 설정한다.

## 4.3.2 기본 생성자
JPA 에서 @Entity와 @Embeddable로 클래스를 매핑하려면 기본 생성자를 제공해야 한다.

기본 생성자는 JPA 프로바이더가 객체를 생성할 때만 사용한다. 그러므로 다른 곳에서 사용하지 못하게 protected로 선언한다.

## 4.3.3 필드 접근 방식 사용
JPA는 필드와 메서드의 두 가지 방식으로 매핑을 처리할 수 있다.
메서드 방식을 사용하려면 get/set을 구현해야 한다.

엔티티에 프로퍼티를 위한 공개 get/set 메서드를 추가하면 도메인의 의도가 사라지고 객체가 아닌 데이터 기반으로 엔티티를 구현할 가능성이 높아진다.

객체가 제공할 기능 중심으로 엔티티를 구현하게끔 유도하려면 JPA 매핑 처리를 프로퍼티 방식이 아닌 필드 방식으로 선택해서 불필요한 get/set 메서드를 구현하지 말아야 한다.

## 4.3.4 AttributeConverter를 이용한 밸류 매핑 처리
AttributeConverter를 사용하면 두 개 이상의 프로퍼티를 한 개 컬럼에 매핑할 수도 있다.
AttributeConverter 인터페이스를 구현한 클래스는 @Converter 애너테이션을 적용한다.
autoApply 속성을 사용하면 모든 Money 타입 프로퍼티에 대해 MoneyConverter를 자동으로 적용한다.

## 4.3.5 밸류 컬렉션: 별도 테이블 매핑
밸류 컬렉션을 별도 테이블로 매핑할 때는 @ElementCollection과 @CollectionTable을 함께 사용한다.

## 4.3.6 밸류 컬렉션: 한 개 컬럼 매핑
밸류 컬렉션을 별도 테이블이 아닌 한 개 칼럼에 저장해야 할 때가 잇다.
이때 AttributeConverter를 사용하면 밸류 컬렉션을 한 개 칼럼에 쉽게 매핑할 수 있다.
단 AttributeConverter를 사용하려면 밸류 컬렉션을 표현하는 새로운 밸류 타입을 추가해야 한다.

## 4.3.7 밸류를 이용한 ID 매핑
식별자라는 의미를 부각시키기 위해 식별자 자체를 밸류 타입으로 만들 수도 있다.
밸류 타입을 식별자로 매핑하면 @Id 대신 @EmbeddedId 애너테이션을 사용한다.

JPA에서 식별자 타입은 Serializable 타입이어야 하므로 식별자로 사용할 밸류 타입은 Serializable 인터페이스를 상속받아야 한다.

## 4.3.8 별도 테이블에 저장하는 밸류 매핑
애그리거트에서 루트 엔티티를 뺸 나머지 구성요소는 대부분 밸류이다.
루트 엔티티 외에 다른 엔티티가 있다면 진짜 엔티티인지 의심해 봐야 한다.
밸류가 아니라 엔티티가 확실하다면 해당 엔티티가 다른 애그리거트는 아닌지 확인해야 한다.

애그리거트에 속한 객체가 밸류인지 엔티티인지 구분하는 방법은 고유 식별자를 갖는지 확인하는 것이다.
하지만 식별자를 찾을 때 매핑되는 테이블의 식별자를 애그리거트의 구성요소의 식별자와 동일한 것으로 착각하면 안 된다.
별도 테이블로 저장하고 테이블에 PK가 있다고 해서 테이블과 매핑되는 애그리거트 구성요소가 항상 고유 식별자를 갖는 것은 아니기 때문이다.

## 4.3.9 밸류 컬렉션을 @Entity로 매핑하기
개념적으로 밸류인데 구현 기술의 한계나 팀 표준 때문에 @Entity를 사용해야 할 때도 있다.

JPA는 @Embeddable 타입의 클래스 상속 매핑을 지원하지 않는다. 상속 구조를 갖는 밸류 타입을 사용하려면 @Embeddable 대신 @Entity를 이용해서 상속 매핑으로 처리해야 한다.

예시에서 Image를 상속받은 클래스는 @Entity와 @Discriminator를 사용해서 매핑을 설정한다.
Image를 담고 있는 Product는 @OneToMany를 이용해서 매핑을 처리한다.

@Entity는 clear 메서드를 사용했을때 느리므로 @Embeddable을 사용할지 @Entity를 사용할지 고민해야 한다.

## 4.3.10 ID 참조와 조인 테이블을 이용한 단방향 M-N 매핑
```java
@Entity
@Table(name = "product")
public class Product {
    //ID...
    
    @ElementCollection
    @CollectionTable(name = "product_category",
            joinColumns = @JoinColumn(name = "product_id"))
    private Set<CategoryId> categoryIds;
}
```
집합의 값에 밸류 대신 연관을 맺는 식별자가 온다.

# 4.4 애그리거트 로딩 전략
JPA 매핑을 설정할 때 항상 기억해야 하는 점은 애그리거트가 속한 객체가 모두 모여야 완전한 하나가 된다는 것이다.
조회 시점에 애그리거트를 완전한 상태가 되도록 하려면 애그리거트 루트에서 연관 매핑의 조회 방식을 즉시 로딩으로 설정하면 된다.

컬렉션에 대해 로딩 전략을 FetchType.EAGER로 설정하면 오히려 즉시 로딩 방식이 문제가 될 수 있다.

애그리거트는 개념적으로 하나여야 하지만 루트 엔티티를 로딩하는 시점에 애그리거트에 속한 객체를 모두 로딩해야 하는 것은 아니다.
애그리거트가 완전해야 하는 이유는 두 가지 정도로 생각해 볼 수 있다.

첫 번째 이유는 상태를 변경하는 기능을 실행할 때 애그리거트 상태가 완전해야 하기 때문이고,
두 번째 이유는 표현 영역에서 애그리거트의 상태 정보를 보여줄 때 필요하기 때문이다.

# 4.5 애그리거트의 영속성 전파
저장하고 삭제할 때도 하나로 처리해야 한다.

# 4.6 식별자 생성 기능
식별자 생성 규칙이 있다면 엔티티를 생성할 때 식별자를 엔티티가 별도 서비스로 식별자 생성 기능을 분리해야 한다.
식별자 생성 규칙은 도메인 규칙이므로 도메인 영역에 식ㄱ별자 생성 기능을 위치시켜야 한다.
식별자 생성 규칙을 구현하기에 적합한 또 다른 장소는 리포지터리다.

# 4.7 도메인 구현과 DIP
DIP를 적용하ㅡㄴ 주된 이유는 저수준 구현이 변경되더라도 고수준이 영향을 받지 않기 위함이다.
하지만 리포지터리와 도메인 모델의 구현 기술은 거의 바뀌지 않는다.

DIP를 완벽하게 지키면 좋겠지만 개발 편의성과 실용성을 가져가면서 구조적인 유연함을 어느 정도 유지하는 편이 합리적인 선택이다.

