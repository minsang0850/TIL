# 소프트웨어 아키텍처 검토
소프트웨어 아키텍처의 역할이 소프트웨어를 만드는 방법을 결정하는 것에만 국한돼서는 안 된다는 점을 명시하는 것도 중요하다.

소프트웨어 아키텍처는 한 사람이 가진 생각의 결실이 되어서는 안 된다.
아키텍처가 진화하고 성숙하기 위해서는 소프트웨어 품질을 개선하기 위한 활동과 관련된 모든 사람과의 협업과 경험이 필요하다.

## 보이지 않는 것들
소프트웨어 아키텍처는 무언가를 올바르게 만드는 것에 관한 것이라고 언급했다.  
따라서 이것은 소프트웨어 아키텍처의 관심사 중에서 보이는 것과 보이지 않는 것 모두를 포함해야 함을 의미한다.

고객에게 보이는 것, 문제 영역에 대한 깊은 이패가 필수적이다. 도메인 주도 설계(DDD) 같은 기법은 문제에 접근하는 데 도움이 될 수 있다.  
도메인 주도 설계는 프로그래머 뿐만 아니라 문제 영역에 포함된 모든 사람에게 적절한 형식으로 소프트웨어를 구조화할 수 있게 한다.  
도메인 주도 설계는 기본 구조를 응집력 있게 정의해 보이지 않는 부분을 형상화하는 데 핵심적인 역할을 하며, 
잘 구조화되고 유지보수가 가능한 방법으로 고객의 요구사항을 처리할 수 있게 한다.

## 기술 부채
기술 부채(technical debt)라는 용어는 소프트웨어 코드 내 존재하는 불필요한 복잡성이 얼마나 존재하는지를 설명하는 데 사용된다.
이러한 불필요한 복잡성을 크러프트(cruft)라고 한다. 크러프트는 현재 코드와 이상적인 코드와의 차이다.

## 악순환
기술 부채는 처리하지 않는다고 해도 반드시 드러나지는 않는다.
기술 부채의 증가를 결정하는 것은 소프트웨어의 변경 속도와 특성이다.

기술 부채를 통제하지 못하면 결국 과부하된 기술 부채 시스템에 새로운 기능을 추가할 만한 가치가 없게 될 것이다.
그 시점에는 애플리케이션을 포기하고 신규 애플리케이션을 만들기 시작한다.
그리고 이러한 주기. 악순환이 반복된다.

## 아키텍처는 모두를 위한 것이 아니다
소프트웨어 아키텍처를 따르도록 규율을 강요하는 것은 어렵다.
기술팀과 경영진 모두 이러한 원치긍ㄹ 따를 때의 이점과 의미에 대해 같은 생각을 갖고 있어야 한다.
고객 기능 면에서는 큰 가치를 더하지 않는 기술적인 측면을 처리하는 데 더 많은 시간을 쓰는 것이 장기적으로 중요한 역할을 할 수 있따는 점을 이해하는 것이 중요하다.
이러한 모든 노력은 더 유지보수하기 쉬운 소프트웨어로 보상받는다.

## 모놀리식 시스템과 분산 시스템
충분한 책임이 축적되는 시점을 안다면 전체 소프트웨어 아키텍처에 대해 다시 생각하고, 때로는 자율적으로 큰 모놀리식 시스템을 런타임 환경에서 격리되는 소프트웨어 구성 요소인 더 작고 관리하기 쉬운 소프트웨어 컴포넌트로 분해할 수 있다.

MSA는 컴퓨팅 및 네트워크 리소스가 예전만큼 비싸지 않고 강력한 디커플링과 더 빠른 소프트웨어 전달과 관련된 많은 이점이 있어서 그렇다.
그러나 여기에도 비용이 든다. 지금까지는 한곳에서 복잡성을 처리해야 했다면, 이제는 네트워크 전체에 흩어진 복잡성을 처리해야 하기 때문이다.

이 책의 헥사고날 아키텍처는 모놀리식 시스템과 분산 시스템 모두에 적용할 수 있다.

## 의사결정
이 모든 논의는 소프트웨어 아키텍처 관심사와 관련 있다.

코드 구조 및 소프트웨어 아키텍처 관련해 우리가 내리는 결정은 내부 품질로 연결된다.

이 책은 최정 결정이 내려졌을 때 변화에 대처할 수 있는 변경에 강한 애플리케이션을 만듦으로써 결정을 미룰 수 있게 해주는 소프트웨어 아키텍처에 관한 것이다.

# 헥사고날 아키텍처 이해
헥사고날 아키텍처의 주된 아이디어 중 하나는 비즈니스 코드를 기술 코드로부터 분리하는 것이다.
그뿐만 아니라 기술 측면이 비즈니스 측면에 의존하는지도 확인해 비즈니스 측면이 비즈니스 목표를 달성하는 데 사용되는 기술에 대한 우려 없이도 발전할 수 있게 해야 한다.
또한 관련된 비즈니스 코드에 피해를 주지 않고도 기술 코드를 변경할 수 있어야 한다.
이러한 목표를 달성하려면 비즈니스 코드가 어디에 존재하는지, 기술 문제로부터 격리되고 보호돼야 하는 위치를 결정해야 한다.
이것은 우리의 첫 번째 헥사곤, 즉 **도메인 헥사곤(Domain hexagon)** 을 생성하게 할 것이다.

도메인 헥사곤에서는 소프트웨어가 해결하기를 원하는 핵심 문제를 설명하는 요소들을 결합한다.
도메인 헥사곤에서 활용된느 주된 요소는 엔티티(entity)와 값 객체(value object)다.
엔티티는 식별자(identity)를 할당할 수 있는 것을 의미하며,
값 객체는 엔티티들을 합성하기 위해 사용하는 불변 컴포넌트다.

또한 도메인 헥사곤에서 나오는 비즈니스 규칙을 사용, 처리하고 조정하는 방법이 필요하다. 이는 **애플리케이션 헥사곤(Application hexagon)** 이 하는 일이다.
애플리케이션 헥사곤은 비즈니스 측면과 기술 측면 사이에서 포트와 유스케이스를 이용해 중개자 역할을 합니다.

**프레임워크 헥사곤**은 외부 인터페이스를 제공한다. 애플리케이션 기능의 노출 방법을 결정할 수 있는 곳이다.
헥사고날 아키텍처에서는 어댑터를 통해 기술 결정을 구체화한다.

e.g.
- REST나 gRPC 엔드포인트를 정의
- 외부 소스에서 무언가를 소비하기 위해 DB< 메시지 브로커, 또는 다른 시스템에서 데이터를 가져오는 메커니즘을 정의하기 위해 프레임워크 헥사곤을 사용한다.

## 도메인 헥사곤
도메인 헥사곤을 실 세계 문제를 이해하고 모델링하는 활동을 나타낸다.
도메인 헥사곤 안에는 중요한 비즈니스 데이터와 규칙에 관련된 엔티티들이 있다. 이것들은 실제 문제에 대한 모델을 나타내기 때문에 중요하다.

문제 영역이 존재하고 도메인 전문가들이 분명하게 알고 있는 상황에서는 문제 영역과 엔티티, 값 객체와 같은 다른 도메인 객체로의 변환 방법을 파악하지 못하면 취약하거나 잘못된 가정을 기반으로 소프트웨어를 구축하게 될 것이다.
초기에는 비즈니스 문제를 해결할 수 있지만, 응집력 있게 변경을 수용할 준비가 되어 있지 않은 취약하고 표현력이 부족한 코드로 이어질 수 있다.

### 엔티티
엔티티는 좀 더 표현력 있는 코드를 작성하는 데 도움을 준다.
객체를 특징짓는 것은 연속성과 정체성에 대한 감각이다.
연속성은 객체의 수명 주기 및 변경 가능한 특성과 관련 있다.

### 값 객체
값 객체는 무언가 고유하게 식별할 필요가 없는 경우는 물론이고, 객체의 정체성보다 속성에 관심을 갖는 경우에도 코드의 표현력을 보완하는 데 도움이 된다.

## 애플리케이션 헥사곤
애플리케이션 헥사곤은 애플리케이션 특화 작업을 추상적으로 처리하는 곳이다.
아직 기술 관심사를 직접 다루지 않기 때문에 추상적인 것을 이야기 한다. 이 헥사곤은 도메인 비즈니스 규칙에 기반한 소프트웨어 사용자의 의도와 기능을 표현한다.

### 유스케이스
유스케이스는 도메인 제약사항을 지원하기 위해 시스템의 동작을 소프트웨어 영역 내에 존재하는 애플리케이션 특화 오퍼레이션을 통해 나타낸다.
유스케이스는 엔티티 및 다른 유스케이스와 직접 상호작용하고 그것들을 유연한 컴포넌트로 만들 수 있다.
자바에서 유스케이스는 소프트웨어가 할 수 있는 것을 표현하는 인터페이스로 정의된 추상화로 나타낸다.
```java
public interface  RegisterUserUseCase {
    List<Rounter> getRouters(Predicate<Router> filter);
}
```

### 입력 포트
유스케이스가 소프트웨어가 하는 일을 설명하는 인터페이스라면 여전히 유스케이스 인터페이스를 구현해야 한다.
이것이 입력 포트의 역할이다.
애플리케이션 수준에서 유스케이스에 직접 연결되는 컴포넌트가 되기 때문에 입력 포트는 도메인 용어로 소프트웨어의 의도를 구현할 수 있게 한다.
```java
public interface RouterViewInputPort implements RouterViewUseCase{
    private RouterViewOutputPort routerListOutputPort;
    
    public RouterViewInputPort(RouterViewOutputPort routerListOutputPort) {
        this.routerListOutputPort = routerListOutputPort;
    }
    
    @Override
    public List<Rounter> getRouters(Predicate<router> filter) {
        var routers = routerListOUtputPort.fetchRouters();
        return Router.retrieveRouter(routers, filter);
    }
}
```

### 출력 포트
유스케이스가 목표를 달성하기 위해 외부 리소스에서 데이터를 가져와야 하는 상황이 있다. 이것이 출력 포트의 역할이다.
출력 포트는 유스케이스나 입력 포트가 오퍼레이션을 수행하기 위해 어떤 종류의 데이터를 외부에서 가져와야 하는지를 기술에 구애받지 않고 설명하는 인터페이스로 표현된다.
```java
public interface RouterViewOutputPort {
    List<Router> fetchRouters();
}
```

## 프레임워크 헥사곤
도메인 헥사곤으로 제한되는 중요한 비즈니스 규칙은 모든 것이 잘 구성된 것처럼 보인다.
다음으로 유스케이스, 입력 포트, 출력 포트를 통해 일부 애플리케이션 특화 오퍼레이션을 다루는 애플리케이션 헥사곤이 뒤따른다.

이제 소프트웨어와 통신할 수 있는 기술을 결정해야 하는 순간이 왔따.
통신은 두 가지 형태로 발생할 수 있다. 하나는 **드라이빙(driving)** 방식이고 다른 하나는 **드리븐(driven)** 방식이다.
드라이버 관점의 경우는 입력 **어댑터(Input Adapter)** 를 사용한다.
드리븐 관점의 경우는 **출력 어댑터(Output Adapter)** 를 사용한다.

### 드라이빙 오퍼레이션과 입력 어댑터
**드라이빙 오퍼레이션(Driving Operation)** 은 소프트웨어에 동작을 요청하는 것이다.
예를 들어, 드라이빙 오퍼레이션은 명령행 클라이언트를 갖는 사용자나 사용자를 대신하는 프론트엔트 애플리케이션이 될 수 있다.
소프트웨어에 의해 노출된 항목들의 정확성을 검사하는 일부 테스트 스위트가 있을 수 있다.

이러한 통신은 어댑터 상단에 구축된 **애플리케이션 프로그래밍 인터페이스(API)** 를 통해 일어난다.

이 API는 외부 엔티티가 시스템과 상호작용하고, 외부 엔티티의 요청을 여러분의 도메인 애플리케이션으로 변환하는 방법을 정의한다.
드라이빙이라는 용어를 사용하는 이유는 이러한 외부 엔티티들이 시스템의 동작을 유도(driving) 하기 때문이다.

**입력 어댑터**는 다음과 같이 애플리케이션에서 지원하는 프로토콜을 정의할 수 있다.
```java
public class RouterViewCLIAdapter {
    RouterViewUseCase routerViewUseCase;
    
    public RouterViewCLIAdapter() {
        setAdapters();
    }
    
    public List<Router> obtainRelatedRouters(String type) {
        return routerViewUseCase.getRouters(
            outer.filterRouterByType(RouterType.valueOf(type)));
    }
    
    private void setAdapters() {
        this.routerViewUseCase = new RouterViewInputPort(RouterViewFileAdapter.getInstance());
    }
}
```
유스케이스 인터페이스를 통해 입력 포트를 사용했다.

### 드리븐 오퍼레이션과 출력 어댑터
드라이빙 오퍼레이션의 반대편에는 드리븐 오퍼레이션(Driven operation)이 있다.
이 오퍼레이션은 애플리케이션에서 트리거되고, 외부에서 소프트웨어 요구사항을 충족시키는 데 필요한 데이터를 가져온다.
일반적으로 드리븐 오퍼레이션은 일부 드라이빙 오퍼레이션에 응답해 발생한다.
상상할 수 있듯 출력 어댑터를 통해서 드리븐 오퍼레이터를 정의한다.

Oracle -> MongoDB로 바꾸는 상황으 ㄹ가정.
처음에는 오라클 DB와 지속성을 허용하는 출력 어댑터만 가지고 있었다.
MongoDB와 통신하기 위해 애플리케이션과 가장 중요한 도메인 헥사곤은 건드리지 말고 그대로 두고, 프레임워크 헥사곤에 출력 데이터를 생성해야 한다.
입력 어댑터와 출력 어댑터 모두 헥사곤 내부를 가리키고 있기 때문에 이것들을 애플리케이션 및 도메인 헥사곤에 종속되게 만들어 의존성을 역전시킨다.

드리븐이라는 용어를 사용하는 이유는 헥사고날 애플리케이션 자체에 의해 이러한 오퍼레이션은 유도되고 통제되며, 다른 외부 시스템에서 동작을 트리거하기 때문이다.
```java
public class RouterViewFileAdapter implements RouterViewOutputPort {
    @Override
    public List<Router> fetchRouters() {
        return readFileAsString();
    }
    
    private static List<Router> readFileAsString() {
        List<Router> routers = new ArrayList<>();
        try (Stream<String> stream = new BufferedReader(
            new InputStreamReader(RouterViewFileAdapter.class.getClassLoader().
                getResourceAsStream("routers.txt"))).lines()){
            stream.forEach(line->{
                String[] routerEntry = line.split(";");
                var id = routerEntry[0];
                var type = routerEntry[1];
                Router router = new Router(RouterType.valueOf(type), RouterId.of(id));
                routers.add(router);
            });
        } catch (Exception e {
            
        }
        return routers;
    }
}
```
출력 포트는 애플리케이션이 외부로부터 필요로 하는 데이터를 나타낸다.

## 헥사고날 접근 방식의 장점
헥사고날 아키텍처는 조직이 소프트웨어를 구성하는 기본 원칙을 수립하는 데 도움이 된다.

변경과 테스트가 쉬운, 유지보수하기 좋은 애플리케이션은 언제나 환영받는다.

## 변경 허용(Change-tolreant)
기술 변화는 빠른 속도로 일어나고 있따.

헥사고날 아키텍처의 포트와 어댑터라는 특성은 마찰이 적고 기술 변화를 흡수할 준비가 되어 있는 애플리케이션을 위한 아키텍처 원칙을 강력한 이점으로 제공한다.

## 유지보수성(Maintainability)
비즈니스 규칙을 변경해야 하는 경우 유일하게 변경해야 하는 것은 도메인 헥사곤이다.
아직 애플리케이션이 지원하지 않는 특정 기술을 허용해야 하는 경우 프레임워크 헥사곤에서 실행할 수 있는 새로운 어댑터를 생성하기만 하면 된다.

## 테스트 용이성(Testability)
헥사고날 아키텍처의 궁극적인 목표 중 하나는 UI와 DB 같은 외부 의존성이 없더라도 개발자가 애플리케이션을 테스트할 수 있께 하는 것이다.