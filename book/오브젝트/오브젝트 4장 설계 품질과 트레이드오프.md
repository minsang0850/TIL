객체지향 설계란 올바른 객체에서 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다.

객체지향 설계의 핵심은 책임이고, 책임을 할당하는 작업이 응집도와 결합도 같은 설계 품질과 깊이 연관돼 있다.

설계는 변경을 위해 존재하고 변경에는 어떤 식으로든 비용이 발생한다. 훌륭한 설계란 합리적인 비용 안에서 변경을 수용할 수 있는 구조를 만드는 것이다.

책임은 객체의 상태에서 행동으로, 나아가 객체와 객체 사이의 상호작용으로 설계 중심을 이동시키고, 결합도가 낮고 응집도가 높으며 구현을 효과적으로 캡슐화하는 객체들을 창조할 수 있는 기반을 제공한다.

## 데이터 중심의 영화 예매 시스템

객체지향 설계에서는 두 가지 방법을 사용해 시스템을 객체로 분할할 수 있다.

첫 번째 방법은 **상태**를 분할의 중심축으로 삼는 방법이고,
두 번째 방법은 **책임**을 분할의 중심축으로 삼는 방법이다.

훌륭한 객체는 데이터(상태)가 아니라 책임에 초점을 맞춰야 한다. 이유는 변경과 관련이 있다.

객체의 상태는 구현에, 책임은 인터페이스에 속한다.

구현은 불안정하기 때문에 변하기 쉽다. 상태를 객체 분할의 중심축으로 삼으면 구현에 관한 세부사항이 인터페이스에 스며들어 캡슐화의 원칙이 무너진다.

### 데이터를 준비하자

데이터 중심 설계란 데이터를 기반으로 시스템을 분할하는 방법이다.

## 설계 트레이드오프

### 캡슐화

캡슐화는 외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 한 종류다.

변경될 가능성이 높은 부분을 구현이라고 부르고 상대적으로 안정적인 부분을 인터페이스라고 부른다.

### 응집도와 결합도

**응집도**

모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다.

객체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는지를 나타낸다.

**결합도**는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도다.

객체지향의 관점에서 결합도는 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있는지를 나타낸다.

일반적으로 좋은 설계란 높은 응집도와 낮은 결합도를 가진 모듈로 구성된 설계를 의미한다.

좋은 설계란 오늘의 기능을 수행하며, 내일의 변경을 수용할 수 있는 설계다.

응집도란 **변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도**로 측정할 수 있다.

응집도가 높을수록 변경의 대상과 범위가 명확해지기 때문에 코드를 변경하기 쉬워진다.

![IMG_2179 2.heic](https://prod-files-secure.s3.us-west-2.amazonaws.com/75d45327-2098-456f-9fc6-68a7a1cbb37c/a3e02a31-9924-424c-9a7e-5768194f797f/IMG_2179_2.heic)

결합도는 **한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도**로 측정할 수 있다.

![IMG_2180 2.heic](https://prod-files-secure.s3.us-west-2.amazonaws.com/75d45327-2098-456f-9fc6-68a7a1cbb37c/a0d8203b-bf7d-4ecf-9622-0ea4cc99436d/IMG_2180_2.heic)

일반적으로 변경될 확률이 매우 적은 안정적인 모듈에 의존하는 것은 아무런 문제도 되지 않는다.

## 데이터 중심의 영화 예매 시스템의 문제점

데이터 중심의 설계는 캡슐화를 위반하고 객체 내부 구현을 인터페이스의 일부로 만든다.

반면 책임 중심의 설계는 객체의 내부 구현을 안정적인 인터페이스 뒤로 캡슐화한다.

**데이터 중심의 설계가 가진 대표적인 문제점**

- 캡슐화를 위반하기 쉬움
- 높은 결합도
- 낮은 응집도

### ******************************캡슐화 위반******************************

getter, setter 메서드는 객체 내부에 인스턴스 변수가 존재한다는 사실을 퍼블릭 인터페이스에 노골적으로 드러낸다. → 캡슐화가 전혀 되지 않음.

캡슐화를 어기게 된 근본적인 원인은 객체가 수행할 책임이 아니라 내부에 저장할 데이터에 초점을 맞췄기 때문이다.

앨런 홀럽(Allen Holub)은 이처럼 접근자와 수정자에 과도하게 의존하는 설계 방식을 추측에 의한 설계 전략(design-by-guessing strategy)이라고 부른다.

이 전략은 객체가 사용될 협력을 고려하지 않고 객체가 다양한 상황에서 사용될 수 있을 것이라는 막연한 추측을 기반으로 설계를 진행한다.

### ****************************높은 결합도****************************

필드의 타입을 변경하면 getter를 사용하는 곳, setter를 사용하는 곳 모두가 변경돼야한다.

그러므로 객체의 구현에 강하게 결합된다.

A에서 B.getC()를 사용해서 C에 직접 접근하는 형태라면 C가 변경이 생길 시 A에도 변경이 필요해진다.

### **************************낮은 응집도**************************

서로 다른 코드들을 하나의 모듈 안에 뭉쳐놨기때문에 변경에 상관 없는 코드들이 영향을 받게 된다.

### 단일 책임 원칙(Single Responsibility Principle, SRP)

클래스는 단 한가지의 변경 이유만 가져야 한다.

## 자율적인 객체를 향해

### 캡슐화를 지켜라

객체는 스스로의 상태를 책임져야하며 외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근할 수 있어야 한다.

1. 코드 중복이 발생할 확률이 높다.
2. 변경에 취약하다.

A를 변경하는 주체는 A가 돼야한다.

→ 객체가 자기 스스로를  책임진다.

### 스스로 자신의 데이터를 책임지는 객체

객체 내부에 저장되는 데이터보다 객체가 협력에 참여하면서 수행할 책임을 정의하는 오퍼레이션이 더 중요하다.

- 이 객체가 어떤 데이터를 포함해야 하는가?
- 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?

## 하지만 여전히 부족하다

### 캡슐화 위반

```jsx
public boolean isDiscountable(DayOfWeek dayOfWeek, LocalTime time) {...}
```

이 메서드는 객체 내부에 DayOfWeek 타입의 요일과 LocalTime 타입의 시간정보가 인스턴수 변수로 포함돼 있다는 사실을 인터페이스를 통해 외부에 노출하고 있다.

```jsx
public boolean isDiscountable(int sequence) {...}
```

이 메서드 역시 객체가 int 타입의 순번 정보를 포함하고 있음을 외부에 노출한다.

### 높은 결합도

캡슐화 위반으로 DiscountCondition의 내부 구현이 외부로 노출됐기 때문에 결합도는 높을 수밖에 없다.

### 낮은 응집도

하나의 변경을 수용하기 위해 코드의 여러 곳을 동시에 변경해야 한다 → 응집도가 낮다.

캡슐화를 위반했기 때문.

## 데이터 중심 설계의 문제점

- 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.
- 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.

### 데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다

이는 데이터와 기능을 분리하는 절차적 프로그래밍 방식을 따른다.

접근자와 수정자를 너무 많이 사용하게 되고, 이는 public 속성과 큰 차이가 없다.

### 데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다

객체지향 설계의 무게 중심은 항상 객체의 내부가 아니라 외부에 맞춰져 있어야 한다.

하지만 데이터 중심 설계에서 초점은 객체의 외부가 아니라 내부로 향한다.

객체의 인터페이스에 구현이 노출된다면 협력이 구현 세부사항에 종속돼고 변경에 영향을 받을 수밖에 없다.