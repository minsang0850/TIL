객체지향 패러다임의 장점은 설계를 재사용할 수 있다는 것이다. 하지만 재사용은 공짜로 얻어지지 않는다.
재사용을 위해서는 객체들의 협력 방식을 일관성 있게 만들어야 한다.

유사한 기능을 구현하기 위해 유사한 협력 패턴을 사용하라.

## 핸드폰 과금 시스템 변경하기
### 기본 정책 확장
고정요금 방식, 시간대별 방식, 요일별 방식, 구간별 방식으로 나뉨.

### 고정요금 방식 구현하기

### 시간대별 방식 구현하기
시간대별 방식의 통화 요금을 계산하기 위해서는 통화의 시작 시간과 종료 시간뿐만 아니라 시작 일자와 종료 일자도 함께 고려해야 한다는 것이다.

- 통화 기간을 일자별로 분리한다.
- 일자별로 분리된 기간을 다시 시간대별 규칙에 따라 분리한 후 각 기간에 대해 요금을 계산한다.  

두 작업을 객체의 책임으로 할당해보자.
통화 기간을 일자 단위로 나누는 작업의 전문가는 DateTimeInterval이다. 
따라서 통화 기간을 일자 단위로 나누는 책임은 DateTimeInterval에게 할당하고 Call이 DateTimeInterval에게 분할을 요청하도록 협력을 설계하는 것이 적절할 것이다.

두 번째 작업인 시간대별로 분할하는 작업의 정보 전문가는 누구인가? 
시간대별 기준을 잘 알고 있는 요금 정책이며 여기서는 TimeOfDayDiscountPolicy라는 이름의 클래스로 구현할 것이다.

TimeOfDayDiscountPolicy는 통화 기간을 알고 있는 Call에게 일자별로 통화 기간을 분리할 것을 요청한다. 
Call은 이 요청을 DateTimeInterval에게 위임한다. 이 값을 토대로 시작시간과 종료시간을 얻는다.

### 요일별 방식 구현하기
요일별 방식은 요일별로 요금 규칙을 다르게 설정할 수 있다.

### 구간별 방식 구현하기
앞선 구현들의 가장 큰 문제점들이 이 클래스들이 유사한 문제를 해결하고 있음에도 불구하고 설계에 일관성이 없다는 것이다.

비일관성은 두 가지 상황에서 발목을 잡는다. 하나는 새로운 구현을 추가해야 하는 상황이고, 또 다른 하나는 기존의 구현을 이해해야 하는 상황이다.
그리고 이 장애물이 문제인 이유는 개발자로서 우리가 수행하는 대부분의 활동이 코드를 추가하고 이해하는 일과 깊숙히 연관돼 있기 때문이다.

결론은 유사한 기능을 서로 다른 방식으로 구현해서는 안 된다.

## 설계에 일관성 부여하기
일관성 있는 설계를 만드는 데 가장 훌륭한 조언은 다양한 설계 경험을 익히라는 것이다.
두 번째 조언은 널리 알려진 디자인 패턴을 학습하고 변경이라는 문맥 안에서 디자인 패턴을 적용해 보라는 것이다.

- 변하는 개념을 변하지 않는 개념으로부터 분리하라.
- 변하는 개념을 캡슐화하라.

### 조건 로직 대 객체 탐색
조건에 따라 분기되는 어떤 로직들이 있다면 이 로직들이 바로 개별적인 변경이라고 볼 수 있다.

클래스를 분리하기 위해서 어떤 기준을 따른느 것이 좋을까? 가장 중요한 기준은 변경의 이유와 주기다. 
클래스는 명확히 단 하나의 이유에 의해서만 변경돼야 하고 클래스 안의 모든 코드는 함게 변경돼야 한다.
간단히 말해서 단일 책임 원칙을 따르도록 클래스를 분리해야 한다는 것이다.

**일관성 있는 협력을 위한 지침**  
- 변하는 개념을 변하지 않는 개념으로부터 분리하라.
- 변하는 개념을 캡슐화하라.  

타입을 캡슐화하기 위해서가 아니라 코드 재사용을 위해 상속을 사용하고 있다면 10장의 주의사항을 살펴보기 바란다.

### 캡슐화 다시 살펴보기
캡슐화는 데이터 은닉 이상이다. 캡슐화란 단순히 데이터를 감추는 것이 아니다.
소프트웨어 안에서 변할 수 있는 모든 '개념'을 감추는 것이다.  
**캡슐화는 변하는 어떤 것이든 감추는 것이다.**  

캡슐화의 가장 대표적인 예는 객체의 퍼블릭 인터페이스와 구현을 분리하는 것이다.

코드 수정으로 인한 파급효과를 제어할 수 있는 모든 기법이 캡슐화의 일종이다.

## 일관성 있는 기본 정책 구현하기
### 변경 분리하기
일관성 있는 협력을 만들기 위한 첫 번째 단계는 변하는 개념과 변하지 않는 개념을 분리하는 것이다.
- 기존 정책은 한 개 이상의 '규칙'으로 구성된다
- 하나의 '규칙'은 '적용조건'과 '단위요금'의 조합이다.

변하지 않는 '규칙'으로부터 변하는 '적용조건'을 분리해야 한다.

### 변경 캡슐화하기
협력을 일관성 있게 만들기 위해서는 변경을 캡슐화해서 파급효과를 줄여야 한다. 
변경을 캡슐화하는 가장 좋은 방법은 변하지 않는 부분으로부터 변하는 부분을 분리하는 것이다.
'규칙'으로부터 '적용조건'을 분리해서 추상화한 후 시간대별, 요일별, 구간별 방식을 이 추상화의 서브타입으로 만든다.
FeeRule로 '규칙', FeeCondition으로 '적용조건' 인터페이스를 만들어서 사용한다.

### 협력 패턴 설계하기

### 추상화 수준에서 협력 패턴 구현하기

### 구체적인 협력 구현하기
현재의 요금제가 시간대별 정책인지, 요일별 정책인지, 구간별 정책인지를 결정하는 기준은 FeeCondition을 대체하는 객체의 타입이 무엇인가에 달려있다.

일관성 있는 협력을 이해하고 나면 변하는 부분만 따로 떼어내어 독립적으로 이해하더라도 전체적인 구조를 쉽게 이해할 수 있다.

### 협력 패턴에 맞추기

### 패턴을 찾아라
일관성 있는 협력의 핵심은 변경을 분리하고 캡슐화하는 것이다. 
변경을 캡슐화하는 방법이 협력에 참여하는 객체들의 역할과 책임을 결정하고 이렇게 결정된 협력이 코드의 구조를 결정한다.
따라서 훌륭한 설계자가 되는 첫걸음은 변경의 방향을 파악할 수 있는 날카로운 감각을 기르는 것이다.
