## 3.1 Blocking I/O
운영체제 측면에서의 I/O는 일반적으로 컴퓨터 시스템이 외부의 입출력 장치들과 데이터를 주고받는 것을 의미하며, 
I/O 작업의 대표적인 예로 디스크에 저장된 프로그램 실행파일을 읽어 들여 메모리에 올리는 것을 들 수 있습니다.

웹 애플리케이션 측면에서 I/O작업에는 어떤 것이 있을까요?
우선 가장 먼저 파일에서 데이터를 읽어 들이거나 파일에 데이터를 기록하는 작업을 떠올릴 수 있습니다.

파일 I/O 외에 데이터베이스에서 데이터를 조회하거나 추가하는 작업 역시 I/O이며, 이를 DB I/O라고 합니다.

그리고 웹 애플리케이션에서 다른 웹 애플리케이션으로 네트워크 통신을 한다면 네트워크 I/O가 발생하는 것입니다.
Apache Tomcat 같은 서블릿 컨테이너 등에서 실행되는 웹 애플리케이션은 동적인 데이터를 처리해야 되기 때문에 어떤 식으로든 I/O가 발생하게 됩니다.

하나의 스레드가 I/O에 의해서 차단되어 대기하는 것을 Blocking I/O라고 합니다.

Blocking I/O 방식의 문제점을 보완하기 위해서 멀티스레딩 기법으로 추가 스레드를 할당하여 차단된 그 시간을 효율적으로 사용할 수는 있습니다.

그런데 이렇게 CPU 대비 많은 수의 스레드를 할당하는 멀티스레딩 기법은 몇 가지 문제점이 존재합니다.

**컨텍스트 스위칭(context Switching)으로 인한 스레드 전환 비용이 발생합니다.**

우리가 컴퓨터상에서 뮤직 플레이어로 음악을 들으면서 동시에 웹 브라우저를 열어서 웹 서피응ㄹ 하고 있다면, 
우리 눈에는 두 개의 프로그램이 동시 실행되고 있는 것처럼 보이지만 실제로 컴퓨터상에서는 두 개의 프로그램을 번갈아 가면서 실행시켜 주는 것입니다.

이렇게 두 개의 프로그램이 번갈아 가며 실행되는 과정에서 기존에 실행되고 있는 프로세스의 정보를 PCB(Process Control Block)라는 공간에 저장하고,
다시 실행시켜야 할 프로세스 정보를 PCB로부터 불러오는 그 과정을 바로 컨테스트 스위칭이라고 합니다.

프로세스의 정보를 PCB에 저장, reload하는 시간 동아넹는 CPU가 다른 작업을 하지 못하고 대기하게 됩니다.
당연히 컨텍스트 스위칭이 많으면 많을수록 CPU의 전체 대기 시간은 길어지기 때문에 성능이 저하되는 것입니다.

**스레드의 컨텍스트 스위칭**
스레드 간에도 컨텍스트 스위칭이 발생합니다.
다만 비교적 적은 정보로 구성된 스레드 정보만 TCB(Thread Control Bloack)라는 공간에 저장하고 reload 하는 과정을 반복하므로 프로세스 간의 컨텍스트 스위칭보다 상대적으로 오버헤드가 적습니다.
그렇다해도 애플리케이션 내에서 대량의 멀티스레드가 지속적으로 생성된다면 시스템에 문제가 발생할 가능성이 그만큼 높아집니다.

### 과다한 메모리 사용으로 오버헤드가 발생할 수 있습니다.
새로운 스레드가 실행되면 JVM 에서는 해당 스레드를 위한 스택 영역의 일부를 할당하며, 새로운 스레드의 정보는 스택 영역에 개별 프레임의 형태로 저장됩니다.

JVM의 디폴트 스택 사이즈는 64비트의 경우 1024KB입니다. 만약에 64,000명이 동시 접속을 한다면, 총 64GB 정도의 메모리가 추가로 필요하게 됩니다.

일반적으로 서블릿 컨테이너 기반의 Java 웹 애플리케이션은 요청당 하나의 스레드를 할당합니다.
만약 각각의 스레드 내부에서 또 다른 작업을 처리하기 위해 스레드를 추가로 할당하게 된다면, 시스템이 감당하기 힘들 정도로 메모리 사용량이 늘어날 가능성이 있습니다.

### 스레드 풀(Thread Pool)에서 응답 지연이 발생할 수 있습니다.
Spring Boot는 자체적으로 톰캣이라는 서블릿 컨테이너를 내장합니다.
그리고 톰캣은 사용자의 요청을 효과적으로 처리하기 위해 스레드 풀을 사용합니다.
스레드 풀이란 일정 개수의 스레드를 미리 생성해서 풀에 저장해두고 사용자의 요청이 들어올 경우,
아직 사용되지 않고 있는 스레드가 있다면 풀에서 꺼내어 사용할 수 있도록 하는 일종의 스레드 저장소입니다.

스레드 풀을 사용하지 않는다면 요청이 드렁올 때마다 스레드를 처음부터 새로 생성해야 하기 때문에 스레드 생성과 수거에 비용이 많이 듭니다.
하지만 스레드 풀을 사용한다고 하더라도 또 다른 문제가 발생할 수 있습니다.

대량의 요청이 발생되어 스레드 풀에 유휴 스레드가 없을 경우, 사용 가능한 스레드가 확보되기 전까지 응답 지연이 발생합니다.

이러한 응답 지연에는 반납한 스레드가 사용 가능하도록 전환되는 지연 시간이 포함됩니다.

## 3.2 Non-Blocking I/O
Non-Blocking I/O는 반대로 스레드가 차단되지 않습니다.

Non-Blocking I/O 방식의 경우, 작업 스레드의 종료 여부와 관계없이 요청한 스레드는 차단되지 않습니다.
Non-Blocking I/O 방식의 경우 스레드가 차단되지 않기 때문에 하나의 스레드로 많은 수의 요청을 처리할 수 있습니다.

더 적은 스레드를 사용하기 때문에 CPU 대기시간 및 사용량에 있어서도 효율적입니다.

**단점**
- 만약에 스레드 내부에 CPU를 많이 사용하는 작업이 포함된 경우에는 성능에 악영향을 줍니다.
- 사용자의 요청에서 응답까지의 전체 과정에 Blocking I/O 요소가 포함된 경우에는 Non-Blocking의 이점을 발휘하기 힘듭니다.

## 3.3 Spring Framework에서의 Blocking I/O와 Non-Blocking I/O
Spring MVC와 Spring WebFlux의 가장 큰 차이점은 바로 Spring MVC는 Blocking I/O 방식이고 Spring WebFlux는 Non-Blocking I/O 방식이라는 점입니다.

## 3.4 Non-Blocking I/O 방식의 통신이 적합한 시스템
### Spring WebFlux를 도입하기 전 고려 사항
**학습 난이도**
Spring WebFlux가 쉽게 느껴지려면 Spring WebFlux의 핵심이 되는 리액티브 스트림즈라는 표준 사양을 구현한 구현체를 능숙하게 사용하기까지 학습에 대한 노력과 시간이 상당히 많이 필요하다고 생각합니다.

**리액티브 프로그래밍 경험이 있는 개발 인력을 확보하는 것이 과연 쉬운가**

### 3.4.1 대량의 요청 트래픽이 발생하는 시스템
일반적으로 애플리케이션에 발생하는 요청 트래픽이 충분히 감당할 수준이라면 서블릿 기반의 Blocking I/O 방식의 애플리케이션으로 충분하다고 생각합니다.

하지만 대량의 트래픽으로 자주 애를 먹는 시스템이라면 Spring WebFlux 기반 애플리케이션으로의 전환을 고려해 볼 만합니다.

### 3.4.2 마이크로 서비스 기반 시스템
마이크로 서비스 기반 시스템은 서비스 간에 많은 수의 I/O가 지속적으로 발생합니다.
따라서 Blocking으로 인한 응답 지연이 발생하게 된다면 해당 서비스뿐만 아니라 다른 서비스들에도 영향을 미칠 가능성이 상당히 높습니다.

### 3.4.3 스트리밍 또는 실시간 시스템
무한 데이터 스트림을 처리하기 위한 스트리밍 또는 실시간 시스템을 쉽게 구축할 수 있습니다.