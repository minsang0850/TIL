### 일반적인 TDD 주기
1. 테스트를 작성한다. 원하는 인터페이스를 개발하라.
2. 실행 가능하게 만든다.
3. 올바르게 만든다.

우리 목적은 작동하는 깔끔한 코드를 얻는 것이다.
작동하는 깔끔한 코드를 얻는 것은 힘든 일이기에 나누어 정복하자(divide and conquer).

'작동하는'에 해당하는 부분을 먼저 해결하고, '깔끔한 코드'에 해당하는 부분을 해결하는 것이다.
이러한 접근 방식은 아케텍처 주도 개발(architecture-driven development)와 정반대다.

테스트는 통과했지만 Dollar에 대해 연산을 수행한 후에 해당 Dollar의 값이 바뀌는 문제점이 있다.
나는 다음과 같이 쓸 수 있길 바란다.
```java
public void testMultiplication() {
    Dollar five = new Dollar(5);
    five.times(2);
    assertEquals(10, product.amount);
    five.times(3);
    assertEquals(15, product.amount);
}
```

테스트를 통과하기 위해서는 올바른 금액을 갖는 새 Dollar를 반환해야 한다.
```java
Dollar times(int multiplier) {
    return new Dollar(amount * multiplier);
}
```

다음은 최대한 빨리 초록색을 보기 위해 취할 수 있는 내가 아는 세 전략 중 두 가지다.
- 가짜로 구현하기
- 명백한 구현 사용하기

저자는 보통 실무에서 TDD를 사용할 때 두 방법을 번갈아가며 사용한다.
모든 일이 자연스럽게 잘 진행되고 내가 뭘 입력해야 할지 알 때는 명백한 구현을 계속 더해 나간다.
예상치 못한 빨간 막대를 만나게 되면 뒤로 한발 물러서서 가짜로 구현하기 방법을 사용하면서 올바른 코드로 리팩토링한다.
그러다 다시 자신감을 되찾으면 명백한 구현 사용하기 모드로 돌아온다.

**검토**
- 설계쌍의 결함(Dollar 부작용)을 그 결함으로 인해 실패하는 테스트로 변환했다.
- 스텁 구현으로 빠르게 컴파일을 통과하도록 만들었다.
- 올바르다고 생각하는 코드를 입력하여 테스트를 통과했다.

느낌(부작용에 대한 혐오감)을 테스트(하나의 Dollar 객체에 곱하기를 두 번 수행하는 것)로 변환하는 것은 TDD의 일반적 주제다.
이런 작업을 오래 할수록 미적 판단을 테스트로 담아내는 것에 점점 익숙해지게 된다.
이걸 할 수 있을 때, 설계 논의는 훨씬 더 흥미로워진다.

