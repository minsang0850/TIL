패턴의 중요한 통찰은 우리가 푸는 문제 대다수는 사용하는 도구에 의해 생기는 것이지 직면한 외부의 문제 때문에 생기는 것이 아니라는 것이다.
이런 이유로, 심지어 외부적 문제 해결 컨텍스트가 엄청나게 다양하더라도 공통의 해결책을 가진 공통의 문제를 발견할 것을 기대할 수 있다.

객체를 적용해서 계산을 조직화하는 것은, 내부 생성된 공통저깅고 부차적인 문제(subproblem)들을 역시 공통적이고 예측 가능한 방법들로 해결하는 가장 좋은 예 중 하나가 된다.

- 커맨드: 계산 작업에 대한 호출(invocation of a computation)을 메시지가 아닌 객체로 표현한다.
- 값 객체: 객체가 생성된 이후 그 값이 절대로 변하지 않게 하여 별칭 문제가 발생하지 않게 한다.
- 널 객체: 계산 작업의 기본 사례를 객체로 표현한다.
- 템플릿 메서드: 계산 작업의 변하지 않는 순서를 여러 추상 메서드로 표현한다.
- 플러거블 객체: 둘 이상의 구현을 객체를 호출함으로써 다양성을 표현한다.
- 플러거블 셀렉터: 객체별로 서로 다른 메서드가 동적으로 호출되게함으로써 필요 없는 하위 클래스의 생성을 피한다.
- 팩토리 메서드: 생성자 대신 메서드를 호출함으로써 객체를 생성한다.
- 임포스터: 현존하는 프로토콜을 갖는 다른 구현을 추가하여 시스템에 변이를 도입한다.
- 컴포지트: 하나의 객체로 여러 개의 행위 조합을 표현한다.
- 수집 매개 변수: 여러 다른 객체에서 계산한 결과를 모으기 위해 매개 변수를 여러 곳으로 전달한다.


### 커맨드
간단한 메서드 호출보다 복잡한 형태의 계산 작업에 대한 호출이 필요하다면 어떻게 해야 할까?
계산 작업에 대한 객체를 생성하여 이를 호출하면 된다.

### 값 객체
널리 공유해야 하지만 동일성(identity)은 중요하지 않을 때 객체를 어떤 식으로 설계할 수 있을까?
객체가 생성될 때 객체의 상태를 설정한 후 이 상태가 절대 변할 수 없도록 한다.
그리고 이 객체에 대해 수행되는 연산은 언제나 새로운 객체를 반환하게 만든다.

**고전적인 별칭 문제**  
두 객체가 제삼의 다른 객체에 대한 참조를 공유하고 있는데, 한 객체가 공유되는 객체의 상태를 변화시키면 나머지 다른 객체는 공유 객체의 상태에 의존하지 않는 편이 차라리 나을 것이다.

**해결**
- 현재 의존하는 객체에 대한 참조를 결코 외부로 알리지 않음. 복사본을 제공. 이 방법은 리소스가 낭비될 수도 이쏙, 공유 객체의 상태 변화를 공유하고 싶은 경우에는 사용할 수 없다는 단점이 있다.
- 옵저버 패턴: 의존하는 객체에 자기를 등록해 놓고, 객체의 상태가 변하면 통지를 받는 방법
- 객체를 덜 객체답게 취급하는 법. 불변 객체.

모든 값 객체는 동등성을 구현해야 한다. 

### 널 객체
특별한 상황을 표현하고 싶을때? 특별한 객체를 사용.

매번 null체크를 하지 않고 절대로 예외를 던지지 않는 새로운 클래스를 만드는 방법이 있다.

### 템플릿 메서드
작업 순서는 변하지 않지만 각 작업 단위에 대한 미래의 개선 가능성을 열어두고 싶은 경우 이를 어떻게 표현할 것인가?

순서들의 범용성에 대해서 명백하게 나타내는 동시에 각 단계의 구현에 대해서는 변화를 주고 싶은 경우가 있따.

예를 들어 JUnit에서는 테스트 메서드를 실행하기 위한 기본 순서를 다음과 같이 구현한다.
```java
// TestCase
public void runBaqre() throws Throwable {
    setUp();
    try {
        runTest();
    }
    finally {
        tearDown();
    }
}
```

하위 클래스는 원하는 대로 setUp(), runTest(), tearDown()을 구현하면 된다.

TestCase.runBare()에서는 세 개의 메서드가 모두 기본 구현ㅇ르 가지고 있다.
- setUp()과 tearDown()은 아무 일도 하지 않는다.
- runTest()는 테스트 메서드를 이름에 기반하여 동적으로 찾아서 호출한다.

템플릿 메서드는 초기의 설계에 의해서 얻어직는 것보다는 경험에 의해 발견되는 것이 좋다.

### 플럭거블 객체
변이를 어떻게 표현할 것인가? 가장 간단한 방법은 명시적인 조건문을 사용하는 것이다.

명시적인 인터페이스를 사용하는 언어에서는 두 플러거블(혹은 그 이상의) 객체가 동일한 인터페이스를 구현하게 해야 한다.

### 플러거블 셀렉터
인스턴스별로 서로 다른 메서드가 동적으로 호출되게 하려면 어떻게 해야 할까?
메서드의 이름을 저장하고 있다가 그 이름에 해당하는 메서드를 동적으로 호출한다.

플러거블 셀렉터 해법은 리플렉션을 이용하여 동적으로 메서드를 호출하는 것이다.

플러거블 셀렉터는 분명 과용될 수 있다.
가장 큰 문제는 메서드가 호출되었는지 보기 위해 코드를 추적하는 것이다.
메서드를 달랑 한 개만 가지는 하위 클래스들이 한 뭉치나 존재하는, 확실히 직관적인 상황에서 코드를 정리하기 위한 용도로만 플러거블 셀렉터를 사용해야 한다.

### 팩토리 메서드
새 객체를 만들 때 유연성을 원하는 경우 객체를 어떻게 생성하는가?
생성자를 쓰는 대신 일반 메서드에서 객체를 생성한다.

생성자는 자신을 잘 표현한다. 생성자를 사용하는 경우 분명히 객체 하나를 생성하고 있따는 것을 알 수 있따.
그러나 생성자는, 특히 자바에서 표현력과 유연함이 떨어진다.

팩토리 메서드의 단점은 인디렉션에 있다.
메서드가 생성자처럼 생기지는 않았지만 그 안에서 객체를 만든다는 사실을 기억해야만 한다.
유연함이 필요할 때에만 팩토리 메서드를 사용해야 한다.

### 사칭 사기꾼
기존의 코드에 새로운 변이를 도입하려면 어떻게 해야 할까? 기존의 객체와 같은 프로토콜을 갖지만 구현은 다른 새로운 객체를 추가한다.

- 널 객체
- 컴포지트 - 객체의 집합을 단일 객체처럼

### 컴포지트
객체 집합을 나타내는 객체를 단일 객체에 대한 임포스터로 구현.

### 수집 매개 변수
여러 객체에 걸쳐 존재하는 오퍼레이션의 결과를 수집하려면 어떻게 해야 할까?
결과가 수집될 객체를 각 오퍼레이션의 매개 변수로 추가한다.

### 싱글톤
전역 변수를 제공하지 않는 언어에서 전역 변수를 사용하려면 어떻게 해야 할까?
프로그램에서 싱글톤으로 해결.
