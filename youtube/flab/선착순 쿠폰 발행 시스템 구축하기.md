
선착순 쿠폰 발행, 과연 "서버 증설"만이 답일까?
- 대규모 트래픽에도 데이터의 정합성 유지 
- 대규모 트래픽에도 서비스의 안정성 유지

### 프로젝트 기능 정의
- 쿠폰 발행은 특정 이벤트 기간에 제한됩니다.
- 쿠폰은 이벤트 기간동안 매일 특정 시간에 시작하여 **일정 시간 동안**만 발행됩니다.
- 쿠폰은 **하루 당 발행 가능한 최대 수량**은 정해져 있습니다.
- 쿠폰은 **선착순**으로 하루에 **한 명의 사용자 당 1개만** 발급 가능합니다.
- 쿠폰 발급 가능 수량은 이벤트 기간 동안 **매일 갱신**됩니다.
- 쿠폰은 이벤트 기간 종료 후 **유효기간 동안** 사용 가능합니다.

### 프로젝트 진행
쿠폰 발행에는 당일 발행한 쿠폰 개수를 업데이트하는 반정규화된 Issued Quantity와 최대 가능 수량인 Max Quantity,
그리고 쿠폰 발행을 기록하는 테이블 이렇게 있습니다.

집계함수 성능 저하를 막기 위해 파생 컬럼(Issed Quantity)을 사용합니다.

**데이터의 정합성 유지 - 기존 방식**
1. 요청 일자가 이벤트 기간 범위 내에 있는지 확인
2. 요청 시간이 이벤트 시간 내에 있는지 확인
3. 쿠폰 발급 수량 초과 확인
   4. issed_quantity 증가 update
5. 중복 발급 확인

**동시성 issue**  
issued Quantity에 함께 접근할 때 race Condition 발생. (두 트랜잭션이 겹칠때)

### Locking 기법 사용  
락 획득, 트랜잭션 처리, 락 해제 방식을 사용

RedissionLock을 선택.
Redis에 부하가 적기 때문

Blocking으로 인해 TPS 감소.

DB는 확장이 어려운데 이 부분도 약점.

### MQ 사용

Redis와 MySQL 사이에 RabbitMQ를 둠.

3초에 하나씩 메시지를 꺼내서 DB에 반영.

Redis에선 이벤트 정보나 쿠폰의 최대 발행 개수 검증.  
검증된 요청들에 대해선 MQ에 적재.  
Scheduling으로 MySQL에 반영.

DB에 반영 됐을때 SSE 알람.

### 테스트
로컬 테스트 JMeter 사용.

락을 획득하는 과정에서 타임아웃이 발생할 수 있음. 
