## 레디스는 무엇이고, 개발자는 왜 레디스를 알아야 할까?
설치부터 사용까지 easy함.  
-> 잘 몰라도 굴러는 감.

## Memcached vs Redis
| **특성**         | **Memcached**    | **Redis**                                                                     |
|----------------|------------------|-------------------------------------------------------------------------------|
| **컨셉**         | Only Cache       | 캐시를 포함해서 Vector database, document database, streaming engine, message broker |
| **데이터모델**      | 단순 키-값 저장소       | 다양한 데이터 구조 지원                                                                 
| **영구성**        | 지원 X             | AOF, RDB(스냅샷)                                                                 |
| **데이터 최대 사이즈** | 1MB              | 512MB                                                                         |
| **클러스터링**      | 클라이언트 측에서 처리해야 함 | 네이티브 클러스터링 지원                                                                 |
| **성능**         | 낮은 레이턴시, 높은 처리량  | 높은 성능, 더 많은 기능으로 인해 약간의 오버헤드 발생                                               |
| **스크립팅**       | 지원하지 않음          | redis-cli, Lua 스크립트 지원                                                        |
| **트랜잭션**       | 간단하게 지원          | 멀티 명령어 트랜잭션 지원(MULTI, EXEC, DISCARD, WATCH))                                  |
| **라이선스**       | BSD 라이선스         | BSD 라이선스                                                                      |
| **멀티 스레드**     | 멀티 스레드           | 싱글 스레드                                                                        |

String 키 값만 사용한다고 단정 짓기 어렵다면.. 활용도와 다양한 기능을 지원해주는 레디스!

## 레디스의 고성능
**싱글스레드임에도 빠른 이유**
- I/O 멀티플렉싱 방식으로 이벤트 루프가 작업 가능한 쓰레드를 작업큐에 넣어줘서 싱글스레드(레디스 엔진)는 I/O 작업 없이 바로 작업 가능

## 레디스6부터는 멀티스레드?
- 네트워크 I/O 작업은 I/O 스레드 풀의 스레드들이 담당해줌.
- io-threads 4가 디폴트: main 스레드 1개, I/O 스레드 3개가 스레드풀에 생김.

## 레디스 StandAlone 모드와 Cluster 모드 차이
| **특성**        | **Redis Standalone 모드**            | **Redis Cluster 모드**                                            |
|---------------|------------------------------------|-----------------------------------------------------------------|
| **구성**        | 단일 인스턴스                            | 여러 인스턴스로 구성된 클러스터                                               |
| **멀티키**       | mset, mget 등으로 사용                  | 클러스터에서 멀티키를 쓰려면 단일 슬롯에 {} 안에 있는 해시 태그를 사용하여 특정 키들이 같은 해시 슬롯에 할당 |
| **데이터 분산**    | 데이터가 하나의 인스턴스에 저장                  | 데이터가 여러 샤드에 분산 저장                                               |
| **확장성**       | 제한적                                | 수평적 확장이 가능                                                      |
| **고가용성**      | 단일 장애점(Single Point of Failure) 존재 | 자동 장애 조치(Failover) 및 고가용성 제공                                    |
| **복제**        | 옵션에 따라 복제 가능 (마스터-슬레이브)            | 네이티브 복제 및 자동 장애 조치                                              |
| **성능**        | 작은 규모의 애플리케이션에 적합                  | 대규모 데이터 처리 및 고성능 요구사항에 적합                                       |
| **관리**        | 관리가 비교적 간단                         | 클러스터 구성 및 관리가 복잡                                                |
| **설정 복잡도**    | 낮음                                 | 높음                                                              |
| **사용 사례**     | 소규모 애플리케이션, 개발 및 테스트 환경            | 대규모 애플리케이션, 고가용성 및 확장성이 중요한 경우                                  |
| **장애 복구**     | 수동 장애 조치 필요                        | 자동 장애 조치 및 재분배                                                  |
| **네트워크 토폴로지** | 단일 노드                              | 여러 노드 및 데이터 리밸런싱 필요                                             |

## 백업
백업 시 fork를 해서 메모리가 2배로 튈 수 있음.

RDB + AOF를 쓰는게 좋다.