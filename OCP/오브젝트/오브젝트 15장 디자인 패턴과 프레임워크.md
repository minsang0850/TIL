소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법을 **디자인 패턴**이라고 부른다.
디자인 패턴의 목적은 설계를 재사용하는 것이다.
디자인 패턴을 익히고 나면 변경의 방향과 주기를 이해하는 것만으로도 필요한 역할과 책임, 역할들의 협력 방식을 순간적으로 떠올릴 수 있게 된다.

디자인 패턴이 설계를 재사용하기 위한 것이라면 **프레임워크**는 설계와 코드를 함께 재사용하기 위한 것이다.
프레임워크는 애플리케이션의 아키텍처를 구현 코드의 형태로 제공한다.

디자인 패턴은 특정한 변경을 일관성 있게 다룰 수 있는 협력 템플릿을 제공한다. 프레임워크는 특정한 변경을 일관성 있게 다룰 수 있는 확장 가능한 코드 템플릿을 제공한다.

## 디자인 패턴과 설계 재사용
### 소프트웨어 패턴
패턴이란 무엇인가를 논의할 때면 반복적으로 어급되는 몇 가지 핵심적인 특징이 있다.
- 패턴은 반복적으로 발생하는 문제와 해법의 쌍으로 정의된다.
- 패턴을 사용함으로써 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있으며, 이 지식을 다른 사람과 의사소통할 수 있다.
- 패턴은 추상적인 원칙과 실제 코드 작성 사이의 간극을 메워주며 실질적인 코드 작성을 돕는다.
- 패턴의 요점은 패턴이 실무에서 탄생했다는 점이다.

패턴으로 인정하기 위한 조건으로 '3의 규칙'을 언급한다. 
이 규칙에 따르면 최소 세 가지의 서로 다른 시스템에 특별한 문제 없이 적용할 수 있고 유용한 경우에만 패턴으로 간주할 수 있다.

패턴이 지닌 가장 큰 가치는 경험을 통해 축적된 실무 지식을 효과적으로 요약하고 전달할 수 있다는 점이다.

패턴은 지식 전달과 커뮤니케이션의 수단으로 활용할 수 있기 때문에 패턴에서 가장 중요한 요소는 패턴의 '이름'이다.

"인터페이스를 하나 추가하고 이 인터페이스를 구체화하는 클래스를 만든 후 객체의 생성자나 setter 메서드에 할당해서 런타임 시에 알고리즘을 바꿀 수 있게 하자"
-> 전략 패턴

크리스토퍼 알렉산더는 연관된 패턴들의 집합들이 모여 하나의 **패턴 언어(Pattern Language)** 를 구성한다고 정의하고 있다.
패턴 언어는 연관된 패턴 카테고리뿐만 아니라 패턴의 생성 규칙과 함께 패턴 언어에 속한 다른 패턴과의 관계 및 협력 규칙을 포함한다.

### 패턴 분류
패턴을 분류하는 가장 일반적인 방법은 패턴의 범위나 적용 단계에 따라 **아키텍처 패턴(Architecture Pattern), 분석 패턴(Analysis Pattern), 디자인 패턴(Design Pattern), 이디엄(Idiom)** 의 4가지로 분류하는 것이다.

디자인 패턴은 특정 정황 내에서 일반적인 설계 문제를 해결하며, 협력하는 컴포넌트들 사이에서 반복적으로 발생하는 구조를 서술한다.
디자인 패턴은 중간 규모의 패턴으로, 특정한 설계 문제를 해결하는 것을 목적으로 하며, 프로그래밍 언어나 프로그래밍 패러다임에 독립적이다.

디자인 패턴의 상위에는 소프트웨어의 전체적인 구조를 결정하기 위해 사용할 수 있는 **아키텍처 패턴**이 위치한다.
아키텍처 패턴은 미리 정의된 서브시스템들을 제공하고, 각 서브시스템들의 책임을 정의하며, 서브시스템들 사이의 관계를 조직화하는 규칙과 가이드라인을 포함한다.
아키텍처 패턴은 구체적인 소프트웨어 아키텍처를 위한 템플릿을 제공하며, 디자인 패턴과 마찬가지로 프로그래밍 언어나 프로그래밍 패러다임에 독립적이다.

디자인 패턴의 하위에는 **이디엄**이 위치한다. 이디엄은 특정 프로그래밍 언어에만 국한된 하위 레벨 패턴으로,
주어진 언어의 기능을 사용해 컴포넌트, 혹은 컴포넌트 간의 특정 측면을 구현하는 방법을 서술한다.

아키텍처 패턴, 디자인 패턴, 이디엄이 주로 기술적인 문제를 해결하는 데 초점을 맞추고 있다면 **분석 패턴**은 도메인 내의 개념적인 문제를 해결하는 데 초점을 맞춘다.
분석 패턴은 업무 모델링 시에 발견되는 공통적인 구조들을 표현하는 개념들의 집합이다.

### 패턴과 책임-주도 설계
패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다.
패턴은 반복적으로 발생하는 문제를 해결하기 위해 사용할 수 있는 공통적인 역할과 책임, 협력의 훌륭한 예제를 제공한다.

패턴을 따르면 특정한 상황에 적용할 수 있는 설계를 쉽고 빠르게 떠올릴 수 있다는 사실이다.

패턴의 구성 요소는 클래스가 아니라 '역할'이다.

패턴을 구성하는 요소가 클래스가 아니라 역할이라는 사실은 패턴 템플릿을 구현할 수 있는 다양한 방법이 존재한다는 사실을 암시한다.
역할은 동일한 오퍼레이션에 대해 응답할 수 있는 책임의 집합을 암시한다.

패턴을 적용하기 위해서는 패턴에서 제시하는 구조를 그대로 표현하는 것이 아니라 패턴의 기본 구조로부터 출발해서 현재의 요구에 맞게 구조를 수정해야 한다는 것을 의미한다.

### 캡슐화와 디자인 패턴
대부분 디자인 패턴의 목적은 특정한 변경을 캡슐화함으로써 유연하고 일관성 있는 협력을 설계할 수 있는 경험을 공유하는 것이다.
디자인 패턴에서 중요한 것은 어떤 디자인 패턴이 어떤 변경을 캡슐화하는지를 이해하는 것이다.

### 패턴은 출발점이다
패턴은 출발점이지 목적지가 아니다.

패턴을 사용하면서 부딪히게 되는 대부분의 문제는 패턴을 맹목적으로 사용할 때 발생한다.
명확한 트레이드오프 없이 패턴을 남용하면 설계가 불필요하게 복잡해지게 된다.

패턴을 적용할 때는 함께 작업하는 사람들이 패턴에 익숙한지 여부를 호가인하고, 그렇지 않다면 설계에 대한 지식과 더불어 패턴에 대한 지식도 함께 공유하는 것이 필요하다.

조슈아 케리에브스키는 패턴을 가장 효과적으로 적용하는 방법은 패턴을 지향하거나 패턴을 목표로 리팩터링하는 것이라고 이야기 한다.

## 프레임워크와 코드 재사용
### 코드 재사용 대 설계 재사용
재사용 관점에서 설계 재사용보다 더 좋은 방법은 코드 재사용이다.

**프레임워크**란 '추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계', 
또는 '애플리케이션 개발자가 현재의 요구사항에 맞게 커스터마이징할 수 있는 애플리케이션의 골격'을 의미한다.  
첫 번째 정의가 프레임워크의 구조적인 측면에 초점을 맞추고 있다면 두 번째 정의는 코드와 설계의 재사용이라는 프레임워크의 사용 목적에 초점을 맞춘다.

### 상위 정책과 하위 정책으로 패키지 분리하기
의존성 역전 원칙의 관점에서 세부 사항은 '변경'을 의미한다.

프레임워크는 여러 애플리케이션에 걸쳐 재사용 가능해야 하기 때문에 변하는 것과 변하지 않는 것들을 서로 다른 주기로 배포할 수 있도록 별도의 '배포 단위'로 분리해야 한다.

프레임워크는 여러 애플리케이션에 걸쳐 일관성 있는 협력을 구현할 수 있께 해준다.
일관성 있는 협력이 제공하는 다양한 장점들은 프레임워크에 대해서도 여전히 적용된다.

### 제어 역전 원리
훌륭한 객체지향 설계는 의존성이 역전된 설계라는 점을 강조한다.

의존성 역전 원리는 프레임워크의 가장 기본적인 설계 메커니즘이다. 의존성 역전은 의존성의 방향뿐만 아니라 제어 흐름의 주체 역시 역전시킨다.

의존성을 역전시키면 제어 흐름의 주체 역시 역전된다. 이를 **제어 역전(Inverdion of Control) 원리**, 또는 **할리우드(Hollywood) 원리**라고 한다.

프레임워크에서는 일반적인 해결책만 제고앟고 애플리케이션에 따라 달라질 수 있는 특정한 동작은 비워둔다.
그리고 이렇게 완성되지 않은 채로 남겨진 동작을 훅(hook)이라고 부른다.
훅의 구현 방식은 애플리케이션의 컨텍스트에 따라 달라진다.

협력을 제어하는 것은 프레임워크라는 것에 주목하라.

우리의 코드는 수동적인 존재다. 프레임워크가 우리의 코드를 호출해줄 때까지 그저 넋 놓고 기다리고 있을 수밖에 없다.
할리우드에서 캐스팅 담당자가 오디션을 보러 온 배우에게 "먼저 연락하지 마세요. 저희가 연락 드리겠습니다"라고 말하는 것처럼 프레임워크는 자신을 찾지 말라고 이야기한다.

제어의 역전이 프레임워크의 핵심 개념인 동시에 코드의 재사용을 가능하게 하는 힘이라는 사실을 이해해야 한다.
