응집도 높은 객체란 책임의 초점이  명확하고 한 가지 일만 잘 하는 객체를 의미한다.  
이런 작은 객체들이 단독으로 수행할 수 있는 작업은 거의 없기 때문에 일반적인 애플리케이션의 기능을 구현하기 위해서는 다른 객체에게 도움을 요청해야 한다.  
협력은 필수적이지만 객체가 다른 객체에 대해 알 것을 강요한다.  
객체의 존재와 수신할 수 있는 메시지에 대해 알아야 하고, 이런 지식이 객체 사이의 의존성을 낳는다.

## 의존성 이해하기
### 변경과 의존성
의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가진다.
- 실행 시점: 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
- 구현 시점: 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.

의존성은 방향성을 가지며 항상 단방향이다.

두 요소 사이의 의존성은 의존되는 요소가 변경될 때 의존하는 요소도 함께 변경될 수 있다는 것을 의미한다. 
따라서 의존성은 변경에 의한 영향의 전파 가능성을 암시한다.
(여기서의 의존성은 UML의 의존성과는 조금 다르다.)

### 의존성 전이
의존성 전이(transitive dependency)가 의미하는 것은  PeriodCondition이 Screening에 의존할 경우 
PeriodCondition은 Screening이 의존하는 대상에 대해서도 자동적으로 의존하게 된다는 것이다.

의존성은 함께 변경될 수 있는 가능성을 의미하기 때문에 모든 경우에 의존성이 전이되는 것은 아니다.
의존성이 실제로 전이될지 여부는 변경의 방향과 캡슐화의 정도에 따라 달라진다.

의존성은 전이될 수 있기 때문에 의존성의 종류를 직접 의존성(direct dependency)와 간접 의존성(indirect dependency)으로 나누기도 한다.

### 런타임 의존성과 컴파일타임 의존성
런타임은 말 그대로 애플리케이션이 실행되는 시점을 가리킨다.  
일반적으로 컴파일타임이란 작성된 코드를 컴파일하는 시점을 가리키지만 문맥에 따라서는 코드 그 자체를 가리키기도 한다. 컴파일타임 의존성이 바로 이런 경우에 해당한다.
컴파일타임 의존성이라는 용어가 중요하게 생각하는 것은 시간이 아니라 우리가 작성한 코드의 구조이기 때문이다.

객체지향 애플리케이션에서 런타임의 주인공은 객체다. 따라서 런타임 의존성이 다루는 주제는 객체 사이의 의존성이다.  
코드 관점에서 주인공은 클래스다. 따라서 컴파일타임 의존성이 다루는 주제는 클래스 사이의 의존성이다.

중요한 것은 런타임 의존성과 컴파일 타임의 의존성이 다를 수 있따는 것이다.
사실 유연하고 재사용 가능한 코드를 설계하기 위해서는 두 종류의 의존성을 서로 다르게 만들어야 한다.
