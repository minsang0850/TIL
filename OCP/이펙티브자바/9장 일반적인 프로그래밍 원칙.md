# 9장 일반적인 프로그래밍 원칙

## 57. 지역변수의 범위를 최소화하라

지역변수의 유효 범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성은 낮아진다.

**지역변수의 범위를 줄이는 가장 강력한 기법은 역시 ‘가장 처음 쓰일 때 선언하기'다.**

거의 모든 지역변수는 선언과 동시에 초기화해야 한다.

try-catch문은 이 규칙에서 예외이다. 변수를 초기화하는 표현식에서 검사 예외를 던질 가능성이 있다면 try 블록 안에서 초기화해야 한다.

반복문은 변수 범위를 최소화해주기에 while보다 for문이 낫다.

```java
Iterator<Element> i = c.iterator();
while (i.hasNext()) {
	doSomething(i.next());
}

Iterator<Element> i2 = c2.iterator();
while (i.hasNext()) { //여기서 오류 발생
	doSomething(i2.next());
}
```

**for문 장점**

- 복사 붙여넣기 오류를 컴파일 타임에 잡아준다.
    - 변수 유효 범위가 for 문 범위와 일치
- while 문보다 짧아서 가독성이 좋다.

지역변수 범위를 최소화하는 마지막 방법은 **메서드를 작게 유지하고 한 가지 기능에 집중하는 것이다.**

→ 메서드를 기능별로 쪼개면 된다.

## 58. 전통적인 for 문보다는 for-each 문을 사용하라

스트림이 제격인 작업이 있고 반복이 제격인 작업이 있다.

for-each문(향상된 for문)을 사용하면 반복자와 인덱스 변수를 사용하지 않으니 코드가 깔끔해지고 오류가 날 일도 없다. 하나의 관용구로 컬렉션과 배열을 모두 처리할 수 있어서 어떤 컨테이너를 다루는지 신경 쓸 필요도 없다.

이중 for문을 사용하면 발견하기 힘든 버그가 발생할 확률도 올라간다.

하지만 for-each문을 사용할 수 없는 상황이 세 가지 존재한다.

- 파괴적인 필터링 - 컬렉션을 순회하면서 선택된 원소를 제거해야 한다면 반복자의 remove 메서드를 호출해야 한다. 자바 8부터는 Collection의 removeIf 메서드를 사용해 컬렉션을 명시적으로 순회하는 일을 피할 수 있다.

```jsx
numbers.add(10);
numbers.add(20);
numbers.add(30);
numbers.add(40);
numbers.add(50);

// 조건에 맞는 요소를 제거
numbers.removeIf(n -> n > 30);
```

- 변형 - 리스트나 배열을 순회하면서 그 원소의 값 혹은 전체를 교체해야 한다면 리스트의 반복자나 배열의 인덱스를 사용해야 한다.
- 병렬 반복 - 여러 컬렉션을 병렬로 순회해야 한다면 각각의 반복자와 인덱스 변수를 사용해 엄격하고 명시적으로 제어해야 한다.

이런 케이스에는 일반 for문을 사용하되, 문제 발생을 경계하라.

for-each 문은 컬렉션, 배열, Iterable 인터페이스를 구현한 객체라면 무엇이든 순회가 가능하다.

원소들의 묶음을 표현하는 타입을 작성해야 한다면 Iterable을 구현하는 쪽으로 고민해보기 바란다.

## 59. 라이브러리를 익히고 사용하라

```jsx
static Random rnd = new Random();

static int random(int n) {
	return Math.abs(rnd.nextInt()) % n;
}
```

위 random 메서드는 세 가지 문제점을 내포하고 있다.

1. n이 그리 크지 않은 2의 제곱수라면 얼마 지나지 않아 같은 수열이 반복된다.
2. n이 2의 제곱수가 아니라면 몇몇 숫자가 평균적으로 더 자주 반환된다. n 값이 크면 이 현상은 더 두드러진다.
3. 지정한 범위 ‘바깥’의 수가 종종 튀어나올 수 있다. rnd.nextInt()가 반환한 값을 Math.abs를 이용해 음수가 아닌 정수로 매핑하기 때문이다.

`Random.nextInt(int)` 같은 api를 사용하는게 낫다.

1. 표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 여러분과 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.
    1. 자바 7 부터는 Random을 더 이상 사용하지 않는 것이 좋다. ThreadLocalRandom으로 대체하면 대부분 잘 작동한다.
2. 핵심적인 일과 크게 관련 없는 문제를 해결하느라 시간을 허비하지 않아도 된다.
3. 따로 노력하지 않아도 성능이 지속해서 개선된다.
    1. 업계 표준 벤치마크를 사용해 성능을 확인하기 때문에 끊임없이 개선된다.
4. 기능이 점점 많아진다.
5. **다른 사람에게 낯익은 코드가 된다.** 

메이저 릴리스마다 주목할 만한 수많은 기능이 라이브러리에 추가 된다.

자바 프로그래머라면 적어도 java.lang, java.utilm java.io와 그 하위 패키지들에는 익숙해져야 한다.

컬렉션 프레임워크와 스트림 라이브러리, java.util.concurrent의 동시성 기능도 알아두면 큰 도움이 된다.

## 60. 정확한 답이 필요하다면 float와 double은 피하라

float와 double 타입은 과학과 공학 계산용으로 설계되었다.

**float와 double 타입은 특히 금융 관련 계산과는 맞지 않는다.**

```java
System.out.println(1.03 - 0.42);
//0.61000000000000001 출력
```

금융 계산에는 BigDecimal, int 혹은 long을 사용해야 한다.

BigDecimal의 단점

- 기본 타입보다 쓰기가 불편하다.
- 느리다.

int나 long으로 대신 사용하는 방법도 있지만 이럴 경우 다룰 수 있는 값의 크기가 제한되고, 소수점을 직접 관리해야 한다.

## 61. 박싱된 기본 타입보다는 기본 타입을 사용하라

자바의 데이터 타입은 int, double, boolean 같은 기본 타입(primitive type)과 String, List 같은 참조 타입으로 나뉜다. 각각의 기본 타입에는 대응하는 참조 타입이 하나씩 있으며, 이를 박싱된 기본 타입(wrapper type)이라고 한다.

오토박싱과 오토언박싱 덕분에 두 타입을 크게 구분하지 않고 사용할 수는 있지만 차이가 없는 것은 아니다.

**차이**

- 기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성(identity)이란 속성을 갖는다. 즉 값이 같아도 서로 다르다고 식별될 수 있다.
- 기본 타입의 값은 언제나 유효하지만, 박싱된 기본 타입은 null을 가질 수 있다.
- 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용 면에서 더 효율적이다.

```java
Comparator<Integer> naturalOrder =
	(i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);
//new Integer(42) 두 개를 비교할 경우 1 출력
```

박싱된 기본 타입에 == 연산자를 사용하면 오류가 일어난다.

기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다.

null 참조를 언박싱하면 NPE 가 발생한다.

기본 타입을 쓸 수 있으면 기본 타입을 쓰는게 좋다.

그렇다면 박싱된 기본 타입은 언제 쓸까?

- 컬렉션의 원소, 키 값으로 쓴다.
    - 매개변수화 메서드의 타입 매개변수로는 박싱된 기본 타입을 써야 한다. `ThreadLocal<Integer>`
- 리플렉션을 통해 메서드를 호출할 때도 박싱된 기본 타입을 사용해야 한다.

## 62. 다른 타입이 적절하다면 문자열 사용을 피하라

**문자열은 다른 값 타입을 대신하기에 적합하지 않다.**

문자열은 열거 타입, 혼합 타입을 대신하기에 적합하지 않다.

문자열은 권한을 표현하기에 적합하지 않다.

문자열 기반 key API는 위조 등의 보안에 취약한 문제가 있다.

## 63. 문자열 연결은 느리지 주의하라

**문자열 연결 연산자(+)로 문자열 n개를 잇는 시간은 n^2에 비례한다.**

문자열은 불변이라서 두 문자열을 연결할 경우 양쪽의 내용을 모두 복사해야 하므로 성능 저하는 피할 수 없는 결과다.

성능을 포기하고 싶지 않다면 String 대신 StringBuilder를 사용하자

StringBuilder는 내부적으로 char배열을 사용한다.
기본 크기 16의 배열로 문자열을 합한 크기가 현재 크기를 초과하면 배열의 크기를 두 배로 늘리는 방식으로 동작한다. 

```java
public String statement() {
	StringBuilder b = new StringBuilder(numItems() * LINE_WIDTH);
	for (int i=0; i< numItems(); i++)
		b.append(lineForItem(i));
	return b.toString();
}
```

## 64. 객체는 인터페이스를 사용해 참조하라

적합한 인터페이스만 있다면 매개변수뿐 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언하라.

인터페이스 타입으로 사용하는 습관을 길러두면 프로그램이 훨씬 유연해질 것이다.

적합한 인터페이스가 없다면 당연히 클래스로 참조해야 한다.

적합한 인터페이스가 없다면 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인(상위의) 클래스를 타입으로 사용하자.

## 65. 리플렉션보다는 인터페이스를 사용하라

리플렉션 기능을 이용하면 프로그램에서 임의의 클래스에 접근할 수 있다.

리플렉션을 이용하면 컴파일 당시에 존재하지 않던 클래스도 이용할 수 있는데, 물론 단점이 있다.

- 컴파일타임 타입 검사가 주는 이점을 하나도 누릴 수 없다.
- 리플렉션을 이용하면 코드가 지저분하고 장황해진다.
- 성능이 떨어진다.

**리플렉션은 아주 제한된 형태로만 사용해야 그 단점을 피하고 이점만 취할 수 있다.**

컴파일 타임에 이용할 수 없는  클래스를 사용해야만 하는 프로그램은 비록 컴파일타임이라도 적절한 인터펭시ㅡ나 상위 클래스를 이용할 수는 있을 것이다. 다행히 이런 경우라면 **리플렉션은 인스턴스 생성에만 쓰고, 이렇게 만든 인스턴스는 인터페이스나 상위 클래스로 참조해 사용하자.**

## 66. 네이티브 메서드는 신중히 사용하라

자바 네이티브 인터페이스는 자바 프로그램이 네이티브 메서드를 호출하는 기술이다. 여기서 네이티브 메서드란 C나 C++같은 네이티브 프로그래밍 언어로 작성한 메서드를 말한다. 네이티브 메서드의 주요 쓰임은 세 가지다.

- 레지스트리 같은 플랫폼 특화 기능을 사용한다.
- 네이티브 코드로 작성된 기존 라이브러리를 사용한다.
- 성능 개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성한다.

**성능을 개선할 목적으로 네이티브 메서드를 사용하는 것은 거의 권장하지 않는다.**

정말 고성능의 다중 정밀 연산이 필요하다면 네이티브 메서드를 통해 GMP를 사용하는 것을 고려해도 좋다.

네이티브 메서드에는 심각한 단점이 있다. 네이티브 언어가 안전하지 않으므로 네이티브 메서드를 사용하는 애플리케이션도 메모리 훼손 오류로부터 더 이상 안전하지 않다. 이식성도 낮고, 디버깅도 어렵고, 속도가 오히려 느려질 수도 있다. GC가 네이티브 메모리는 자동 회수하지 못하고, 심지어 추적조차 할 수 없다.

## 67. 최적화는 신중히 하라

성능 때문에 견고한 구조를 희생하지 말자. 빠른 프로그램보다는 좋은 프로그램을 작성하라.

- 성능을 제한하는 설계를 피하라.
- API를 설계할 때 성능에 주는 영향을 고려하라.
- 성능을 위해 API를 왜곡하는 건 매우 안 좋은 생각이다.
- 각각의 최적화 시도 전후로 성능을 측정하라.

## 68. 일반적으로 통용되는 명명 규칙을 따르라

자바 플랫폼은 명명 규칙이 잘 정립되어 있다.

패키지와 모듈 이름은 각 요소를 점(.)으로 구분하여 계층적으로 짓는다. 요소들은 모두 소문자 알파벳 혹은 (드물게) 숫자로 이뤄진다. 여러분 조직 바깥에서도 사용될 패키지라면 조직의 인터넷 도메인 이름을 역순으로 사용한다.

클래스와 인터페이스의 이름은 하나 이상의 단어로 이뤄지며, 각 단어는 대문자로 시작한다.

널리 통용되는 줄임말을 제외하고 단어을 줄여쓰지 않도록 한다.

메서드와 필드 이름은 첫 글자를 소문자로 쓴다는 점만 빼면 클래스와 규칙이 같다.

상수 필드는 모두 대문자로 쓰며 단어 사이는 밑줄로 구분한다. 상수 필드는 값이 불변인 static final 필드를 말한다.

타입 매개변수 이름은 보통 한 문자로 표현한다.

- 임의의 타입엔 T
- 컬렉션 원소의 타입은 E
- 맵의 키와 값에는 K와 V
- 예외에는 X
- 메서드의 반환 타입에는 R
- 그 외의 임의 타입의 시퀀스에는 T, U, V 혹은 T1, T2, T3를 사용한다.

객체를 생성할 수 있는 클래스의 이름은 보통 단수 명사나 명사구를 사용한다.

객체를 생성할 수 없는 클래스의 이름은 보통 복수형 명사로 짓는다(Collectors, Collections). 인터페이스 이름은 클래스와 똑같이 짓는다. 애너테이션은 두루두루 쓰인다.

boolean 값을 반환하는 메서드는 보통 is나 has로 시작한다.

인스턴스의 속성을 반환하는 메서드의 이름은 명사, 명사구 혹은 get으로 시작하는 동사구로 짓는다.