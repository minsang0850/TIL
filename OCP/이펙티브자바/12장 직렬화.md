# 12장 직렬화

객체 직렬화란 자바가 객체를 바이트 스트림으로 인코딩하고(직렬화) 그 바이트 스트림으로부터 다시 객체를 재구성하는(역직렬화) 메커니즘이다. 직렬화된 객체는 다른 VM에 전송하거나 디스크에 저장한 후 나중에 역직렬화할 수 있다.

## 85. 자바 직렬화의 대안을 찾으라

직렬화의 근본적인 문제는 공격 범위가 너무 넓고 지속적으로 더 넓어져 방어하기 어렵다는 점이다. ObjectInputStream의 readObject 메서드를 호출하면서 객체 그래프가 역직렬화되기 때문이다. readObject 메서드는 (Serializable 인터페이스를 구현했다면) 클래스패스 안의 거의 모든 타입의 객체를 만들어 낼 수 있는, 사실상 마법 같은 생성자다. 바이트 스트림을 역직렬화하는 과정에서 이 메서드는 그 타입들 안의 모든 코드를 수행할 수 있다. 결국 그 타입들의 코드 전체가 공격 범위에 들어간다는 뜻이다.

자바의 표준 라이브러리나 아파치 커먼즈 컬렉션 같은 서드파티 라이브러리는 물론 애플리케이션 자신의 클래스들도 공격 범위에 포함된다. 관련한 모든 모범 사례를 따르고 대비해도 애플리케이션은 여전히 취약할 수 있다.

역직렬화 과정에서 위험한 동작을 수행하는 메서드를 찾아보았다. 이런 메서드를 가젯(gadget)이라 부른다. 여러 가젯을 함꼐 사용해 가젯 체인을 구성할 수도 있는데, 가끔씩 공격자가 기반 하드웨어의 네이티브 코드를 마음대로 실행할 수 있는 아주 강력한 가젯 체인도 있다.

그래서 아주 신중하게 제작한 바이트 스트림만 역직렬화해야 한다.

역직렬화에 시간이 오래 걸리는 짧은 스트림을 역직렬화하는 것만으로도 서비스 거부 공격에 노출될 수 있다. 이런 스트림을 역직렬화 폭탄(deserialization bomb)이라 한다.

**직렬화 위험을 회피하는 가장 좋은 방법은 아무것도 역직렬화하지 않는 것이다.**

**여러분이 작성하는 새로운 시스템에서 자바 직렬화를 써야 할 이유는 전혀 없다.**

객체의 바이트 시퀀스를 변환해주는 다른 메커니즘이 많이 있는데, 자바 직렬화와 구분하고자 크로스-플랫폼 구조화된 데이터 표현(cross-platform structured-data-representation)이라 한다.

크로스-플랫폼 구조화된 데이터 표현의 선두주자는 JSON과 프로토콜 버퍼다.

JSON은 텍스트 기반이라 사람이 읽을 수 있고, 프로토콜 버퍼는 이진 표현이라 효율이 훨씬 높다.

JSON은 데이터를 표현하는 데만 쓰이지만, 프로토콜 버퍼는 문서를 위한 스키마(타입)을 제공하고 올바로 쓰도록 강요한다.

레거시 시스템 때문에 자바 직렬화를 완전히 배제할 수 없을 때의 차선책은 **신뢰할 수 없는 데이터는 절대 역직렬화하지 않는 것이다.**

직렬화를 피할 수 없고 역직렬화한 데이터가 안전한지  완전히 확신할 수 없다면 객체 역직렬화 필터링(java.io.ObjectInputFilter)을 사용하자. 객체 역직렬화 필터링은 데이터 스트림이 역직렬화되기 전에 필터를 설치하는 기능이다. 클래스 단위로, 특정 클래스를 받아들이거나 거부할 수 있다.

‘기본 수용’ 모드에서는 블랙리스트에 기록된 잠재적으로 위험한 클래스들을 거부한다. 반대로 ‘기본 거부’ 모드에서는 화이트리스트에 기록된 안전하다고 알려진 클래스듦나 수용한다.

**블랙리스트 방식보다는 화이트리스트 방식을 추천한다.**

블랙리스트는 알려진 위험으로부터만 보호할 수 있기 때문이다.

필터링 기능은 메모리를 과하게 사용하거나 객체 그래프가 너무 깊어지는 사태로부터도 보호해주지만, 직렬화 폭탄은 걸러내지 못한다.

## 86. Serializable을 구현할지는 신중히 결정하라

어떤 클래스의 인스턴스를 직렬화할 수 있게 하려면 클래스 선언에 implements Serializable만 붙이면 된다.

Serializable을 구현하면 릴리스한 뒤에는 수정하기 어렵다.

클래스가 Serializable을 구현하면 직렬화된 바이트 스트림 인코딩도 하나의 공개 API가 된다. 이 클래스가 널리 퍼진다면 그 형태도 영원히 지원해야 하는 것이다. 기본 직렬화에서는 private와 package-private 인스턴스 필드들마저 공개되는 꼴이 된다.

직렬화가 클래스 개선을 방해하는 간단한 예를 보자. 대표적으로는 스트림 고유 식별자, 즉 직렬 버전 UID(serial version UID)를 들 수 있다. 모든 직렬화된 클래스는 고유 식별 번호를 부여받는다. serialVersionUID라는 이름의 static final long 필드로, 이 번호를 명시하지 않으면 시스템이 런타임에 암호화해서 함수를 적용해 자동으로 클래스 안에 생성해 넣는다. 이 때 모든 클래스 멤버들이 고려되기에 메서드 하나라도 추가되면 UID 값이 변해 호환성이 깨져버리고, INvalidClassException이 발생할 것이다.

**Serialiable 구현의 두 번째 문제는 버그와 보안 구멍이 생길 위험이 높아진다는 점이다.**

**Serialiable 구현의 두 번째 문제는 해당 클래스의 신버전을 릴리스할 때 테스트할 것이 늘어난다는 점이다.**

**Serializable 구현 여부는 가볍게 결정할  사안이 아니다.**

상속용으로 설계된 클래스는 대부분 Serializable을 구현하면 안 되며, 인터페이스도 대부분 Serializable을 확장해서는 안 된다.

상속용으로 설계된 클래스 중 Serializable을 구현한 예로는 Throwable과 Component가 있다.

여러분이 작성하는 클래스의 인스턴스 필드가 직렬화와 확장이 모두 가능하다면 주의할 점이 몇 가지 있다. 인스턴스 필드 값 중 불변식을 보장해야 할 게 있다면 반드시 하위 클래스에서 finalize 메서드를 재정의하지 못하게 해야 한다.

인스턴스 필드 중 기본값으로 초기화되면 위배되는 불변식이 있다면 클래스에 다음의 readObjectNodata 메서드를 반드시 추가해야 한다.

```java
private void readObjectNoData() throws InvalidObjectException {
	throw new InvalidObjectException("스트림 데이터가 필요합니다");
}
```

이 메서드는 자바 4의 추가된 것으로, 기존의 직렬화 가능 클래스에 직렬화 가능 상위 클래스를 추가하는 드문 경우를 위한 메서드다.

내부 클래스에서는 직렬화를 구현하지 말아야 한다.

## 87. 커스텀 직렬화 형태를 고려해보라

먼저 고민해보고 괜찮다고 판단될 떄만 기본 직렬화 형태를 사용하라.

객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태라도 무방한다.

기본 직렬화 형태가 적합하다고 결정했더라도 불변식 보장과 보안을 위해 readObject 메서드를 제공해야 할 때가 많다.

객체의 물리적 표현과 논리적 표현의 차이가 클 때 기본 직렬화 형태를 사용하면 크게 네 가지 면에서 문제가 생긴다.

1. 공개 API가 현재의 내부 표현 방식에 영구히 묶인다.
2. 너무 많은 공간을 차지할 수 있다.
3. 시간이 너무 많이 걸릴 수 있다.
4. 스택 오버플로를 일으킬 수 있다.

기본 직렬화 사용 여부와 상관 없이 객체의 전체 상태를 읽는 메서드에 적용해야 하는 동기화 메커니즘을 직렬화에도 적용해야 한다.

어떤 직렬화 형태를 택하든 직렬화 가능 클래스 모두에 직렬 버전 UID를 명시적으로 부여하자.

구버전으로 직렬화된 인스턴스들과의 호환성을 끊으려는 경우를 제외하고는 직렬 버전 UID를 절대 수정하지 말자.

## 88. readObject 메서드는 방어적으로 작성하라

readObject 메서드가 실질적으로 또 다른 public 생성자이기 때문에 다른 생성자와 똑같은 수준으로 주의를 기울여야 한다. 보통의 생성자처럼 인수가 유효한지 검사해야 하고 필요하다면 매개변수를 방어적으로 복사해야 한다.

쉽게 말해, readObject는 매개변수로 바이트 스트림을 받는 생성자라 할 수 있다.

**객체를 역직렬화할 때는 클라이언트가 소유해서는 안 되는 객체 참조를 갖는 필드를 모두 반드시 방어적으로 복사해야 한다.**

final 필드는 방어적 복사가 불가능하니 주의하자.

## 89. 인스턴스 수를 통제해야 한다면 readResolve 보다는 열거 타입을 사용하라

클래스는 선언에 implements Serializable을 추가하는 순간 더 이상 싱글턴이 아니게 된다.

기본 직렬화를 쓰지 않아도, 명시적인 readObject를 제공해도 소용 없다. 어떤 readObject를 사용하든 이 클래스가 초기화될 때 만들어진 인스턴스와는 별개인 인스턴스를 반환하게 된다.

readResolve 기능을 이용하면 readObject가 만들어낸 인스턴스를 다른 것으로 대체할 수 있다. 역직렬화한 객체의 클래스가 readResolve 메서드를 적절히 정의해뒀다면, 역직렬화 후 새로 생성된 객체를 인수로 이 메서드가 호출되고, 이 메서드가 반환한 객체 참조가 새로 생성된 객체를 대신해 반환된다. 대부분의 경우 이때 새로 생성된 객체의 참조는 유지하지 않으므로 GC의 대상이 된다.

사실, readResolve를 인스턴스 통제 목적으로 사용한다면 객체 참조 타입 인스턴스 필드는 모두 transient로 선언해야 한다.

readResolve 메서드의 접근성은 매우 중요하다. final 클래스에서라면 readResolve 메서드는 private이어야 한다.

## 90. 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라

직렬화 프록시 패턴은 그리 복잡하지 않다.

먼저, 바깥 클래스의 논리적 상태를 정밀하게 표현하는 중첩 클래스를 설계해 private static으로 선언한다. 이 중첩 클래스가 바로 바깥 클래스의 직렬화 프록시다. 중첩 클래스의 생성자는 단 하나여야 하며, 바깥 클래스를 매개변수로 받아야 한다. 이 생성자는 단순히 인수로 넘어온 인스턴스의 데이터를 복사한다. 일관성 검사나 방어적 복사도 필요 없다.

```java
//직렬화 프록시 패턴용 writeReplace 메서드
private Object writeReplace() {
	return new SerializationProxy(this);
}

//직렬화 프록시 패턴용 readObject 메서드
private void readObject(ObjectInputStream stream)
	throws InvalidObjectException {
		throw new InvalidObjectException("프록시가 필요합니다.");
}

//Period.SerializationProxy용 readResolve 메서드
private Objcet readResolve() {
	return new Period(start, end);
}
```

직렬화 프록시 패턴에는 한계가 두 가지 있다.

1. 클라이언트가 멋대로 확장할 수 있는 클래스에는 적용할 수 없다.
2. 객체 그래프에 순환이 있는 클래스에도 적용할 수 없다.
3. 속도가 조금 느리다.