## 문자열 해시 코드
해시 인덱스는 배열의 인덱스로 사용해야 하므로,숫자(양의 정수)만 사용할 수 있다.

문자 데이터를 기반으로 숫자 해시 인덱스를 구하려면 어떻게 해야 할까?


```java
public class StringHashCode {
    static int hashCode(String s) {
        int hash = 0;
        for (int i = 0; i < s.length(); i++) {
            hash = (hash << 5) + s.charAt(i);
        }
        return hash;
    }
}
```

### 해시 코드와 해시 인덱스
해시 코드를 배열 용량으로 나눠서 해시 인덱스로 사용.

**해시 함수**
- 임의의 길이의 데이터를 입력으로 받아, 고정된 길이의 해시값을 출력하는 함수이다.
  - 여기서 의미하는 고정된 길이는 저장 공간의 크기를 뜻한다.
- 같은 데이터를 입력하면 항상 같은 해시 코드가 출력된다.
- 다른 데이터를 입력해도 같은 해시 코드가 출력될 수 있다.
  - 이를 해시 충돌이라고 한다.

**해시 코드**
- 해시 코드는 데이터를 대표하는 값을 뜻한다. 보통 해시 함수를 통해 만들어진다.

**해시 인덱스**
- 데이터의 저장 위치를 결정한다.
- 보통 해시 코드의 결과에 배열의 크기를 나누어 구한다.

## Java의 hashCode()
해시 인덱스를 사용하는 해시 자료 구조는 연산 성능이 O(1)로 매우 빠르다.

Java의 모든 타입을 해시 자료 구조에 저장하려면 모든 객체가 숫자 해시 코드를 제공할 수 있어야 한다.


## HashSet 구현
Object.hashCode() 를 사용해서 해시코드를 구하고 (절대값 사용), 해시코드를 배열의 크기로 나눠서 해시 인덱스를 구한다.

## Equals와 hashCode
**Object의 기본 기능**
- hashCode(): 객체의 참조값 기반 해시 코드 반환
- equals(): == 동일성 비교를 한다. 따라서 참조값이 같아야 true를 반환한다.

hashCode()를 오버라이딩하면 equals()도 오버라이딩해야 한다.

equals를 오버라이딩하지 않으면 해시 인덱스는 찾지만 객체를 비교할 수 없다. <- 내가 찾는 객체가 뭔지 확인해야하기 때문에 equals 오버라이딩이 필요하다.

hash 알고리즘의 기본은 충돌이 나지 않도록 하는 것이 성능에 가장 중요하다.